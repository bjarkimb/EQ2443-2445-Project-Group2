<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.11">
  <compounddef id="page_exploring_gnuradio" kind="page">
    <compoundname>page_exploring_gnuradio</compoundname>
    <title>Exploring GNU Radio</title>
    <detaileddescription>
<para>Let&apos;s explore over two examples that are shipped with GNU Radio. We start off with a very simple dial tone generating example that is done in Python. The second example uses both GNU Radio Companion (GRC) and Python for different stages of the example.</para><para>In either case, we will be actually working with Python code and the modules as they exist in Python. However, in the following discussion, we will refer to each block using the full C++ namespace so that we can easily link to the block&apos;s documentation inside the manual.</para><para>The example files discussed in this page are installed with the documentation and are located in $prefix/share/doc/gnuradio-$version/.</para><sect1 id="page_exploring_gnuradio_1ex_dial_tone">
<title>Dial Tone Example</title>
<para>This example is found in the dial_tone.py file and constructs a very simple GNU Radio application that combines two sine waves to create a dial tone. It calls a function to construct the flowgraph which handles generating the signal sources.</para><para>The build_graph function sets up the sampling rate, which we will use to set the rate of the audio sink as well as the amplitude, which we use to scale the signal to control the volume of the output. We then create a top_block. The top_block is the object that holds the flowgraph, the basic data structure of a GNU Radio application. We will use the top_block to connect together and hold the signal processing blocks, which we build next.</para><para>This example uses three signal processing blocks. The first two are <ref refid="classgr_1_1analog_1_1sig__source__f" kindref="compound">gr::analog::sig_source_f</ref> blocks, which generate sine waves at frequencies 350 and 440 Hz. We next create the connection to the speaker system using <ref refid="classgr_1_1audio_1_1sink" kindref="compound">gr::audio::sink</ref>, which takes in the sample rate it will use to produce the output signal. The audio sink block can also take in a second parameter to set the output device name, which we use if there is a resource conflict or if using a sampling rate that the hardware won&apos;t naturally support. Common device names are &quot;pulse&quot; if using PulseAudio or &quot;plughw:0,0&quot;, which is an ALSA device that can handle resampling.</para><para>We next take the three blocks we&apos;ve built and connect together the flowgraph. The flowgraph connects sources to sinks through other signal processing blocks. Here, we are directly connecting two sources to a single sink. The next example uses more complex flowgraphs to further explore these concepts. The two lines containing the &quot;tb.connect&quot; statements are where the connections are made. The flowgraph will look like:</para><para><verbatim>sig_source_f (freq = 350) --&gt;
                              audio.sink
sig_source_f (freq = 440) --&gt;
</verbatim></para><para>We&apos;re inputting two signals into a single block, which with the audio sink allows us to output in stereo. The two signals combine to form the dual frequencies of a standard dial tone.</para><para>In the connection of the signal source to the audio sink, notice how we specify the sink as a Python tuple, (dst, X). Technically, we specify all connections as ((source block, port out), (sink block, port in)) because each block that outputs samples can have multiple output ports just as a block that receives samples can have multiple input ports. However, in the case of a <ref refid="classgr_1_1analog_1_1sig__source__f" kindref="compound">gr::analog::sig_source_f</ref>, it only produces samples on a single output and so the output port of 0 is implied. Otherwise, we could write this as &quot;tb.connect((src0, 0),
(dst,0))&quot; for complete representation of the connection.</para><para>When we are done connecting the blocks, we have a flowgraph in the object &quot;tb&quot;. While it&apos;s connected, the sources are not generating any samples. We have to start running the flowgraph. In the main section, we return the top_block object and then call the &quot;start&quot; function on it. This is a non-blocking call that launches the flowgraph&apos;s main thread, which initiates the sources to start sending samples through the flowgraph. We then block until the user presses &quot;Enter&quot; at which point we call the flowgraph&apos;s &quot;stop&quot; function to shut it down.</para></sect1>
<sect1 id="page_exploring_gnuradio_1ex_fm_demod">
<title>FM Demodulator</title>
<para>This example can be done completely in GRC or both GRC and Python. We will generate an FM signal using GRC first and then using either a GRC program or an example in Python to demodulate and play it back.</para><sect2 id="page_exploring_gnuradio_1Modulator">
<title>Modulator</title>
<para>We first launch GRC using the terminal command &quot;gnuradio-companion&quot;. This starts the graphical interface to create our flowgraphs. We won&apos;t explore the GRC interface here; just use it to generate a data file. With GRC launched, open the file &quot;fm_tx.grc&quot;. Exploring this flowgraph, it generates the dial tone frequencies, adds them together, resamples the signal so we can use integer upsampling in the wideband FM transmitter block (WBFM Transmit) and output the data. While this is happening, we&apos;re also outputting the original signal to the audio system as well as viewing it in time and frequency at different stages.</para><para>The intent of this example is to generate a frequency-modulated dial tone signal and save it to a file. While saving it to a file, we only want to generate a signal large enough to make use of it, but it doesn&apos;t have to be too large. So we put a <ref refid="classgr_1_1blocks_1_1head" kindref="compound">gr::blocks::head</ref> block that limits the number of samples into the file sink. Once this block has seen N number of samples, it will stop the flowgraph. Meanwhile, we use a <ref refid="classgr_1_1blocks_1_1skiphead" kindref="compound">gr::blocks::skiphead</ref> block to ignore the first M samples, which helps us avoid the transients and group delay of the filters in the system.</para><para>We run this either using the menu &quot;Build-&gt;Execute&quot; or using the play button on the toolbar. It will run for a short amount of time and stop once the head has seen the items set in the &quot;nitems&quot; parameter. The result is a file &quot;dummy.dat&quot; that contains the complex FM samples.</para></sect2>
<sect2 id="page_exploring_gnuradio_1Demodulator">
<title>Demodulator</title>
<para>The demodulator part is shown in both a GRC graph and as a Python script. Both the GRC graph, &quot;fm_rx.grc&quot;, and the Python script, &quot;fm_demod.py&quot;, do the same thing and basically reverse the stages of the modulator. It uses a <ref refid="classgr_1_1blocks_1_1file__source" kindref="compound">gr::blocks::file_source</ref> to read the &quot;dummy.dat&quot; file we created previously. This is sent to the FM demodulator, which is simply implemented here using the <ref refid="classgr_1_1analog_1_1quadrature__demod__cf" kindref="compound">gr::analog::quadrature_demod_cf</ref>. This demodulates the signal and converts the complex FM signal to a float signal.</para><para>We then resample it from the input signal at 200 ksps to the audio rate of 44.1 ksps. Because this resampling cannot be done using an integer decimation rate, we use an arbitrary resampler, the <ref refid="classgr_1_1filter_1_1pfb__arb__resampler__fff" kindref="compound">gr::filter::pfb_arb_resampler_fff</ref> block, that allows us to resample at any rate as well as filter the signal to the audio rate we want. The output of this block is filtered to a 15 kHz bandwidth at a sample rate of 44.1 ksps, which is ready for the <ref refid="classgr_1_1audio_1_1sink" kindref="compound">gr::audio::sink</ref> block.</para><para>Both the GRC and Python files can be explored further to better understand the operations of the blocks. </para></sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
