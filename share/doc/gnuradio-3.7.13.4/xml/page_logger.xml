<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.11">
  <compounddef id="page_logger" kind="page">
    <compoundname>page_logger</compoundname>
    <title>Logging</title>
    <detaileddescription>
<sect1 id="page_logger_1logging">
<title>Logging</title>
<para>GNU Radio has a logging interface to enable various levels of logging information to be printed to the console or a file. The logger derives from log4cpp (<ulink url="http://log4cpp.sourceforge.net/">http://log4cpp.sourceforge.net/</ulink>) which is readily available in most Linux distributions. This is an optional dependency and GNU Radio will work without it.</para><para>When configuring GNU Radio, the -DENABLE_GR_LOG=On|Off option to cmake will allow the user to toggle use of the logger on and off. The logger defaults to &quot;on&quot; and will use log4cpp if it is available. If log4cpp is not found, the default logging will output to standard output or standard error, depending on the level of the log message.</para><para>Logging is useful for blocks to print out certain amounts of data at different levels. These levels are:</para><para><preformatted>
    DEBUG &lt; INFO &lt; WARN &lt; TRACE &lt; ERROR &lt; ALERT &lt; CRIT &lt; FATAL &lt; EMERG
</preformatted></para><para>The order here determines the level of output. These levels are hierarchical in that specifying any level also includes any level above it. For example, when using the INFO level, all INFO and higher messages are logged and DEBUG is ignored. A level NOTSET is provided to disable a logger.</para><sect2 id="page_logger_1configfile">
<title>Logging Configuration</title>
<para>The logging configuration can be found in the gnuradio-runtime.conf file under the [LOG] section. This allows us fairly complete control over the logging facilities. The main configuration functions are to set up the level of the loggers and set the default output behavior of the loggers.</para><para>There are two default loggers that all gr_block&apos;s have access to: d_logger and d_debug_logger. The first is a standard logger meant to output simple information about the block while it is running. The debug logger is meant for debugging purposes and is added to make it convenient to use a secondary logger that outputs to a different stream or file.</para><para>The four main configure options are:</para><para><preformatted>
  log_level = debug
  debug_level = debug
  log_file = stdout
  debug_file = stderr
</preformatted></para><para>This establishes the two loggers as having access to all levels of logging events (DEBUG through EMERG). They are also configured not to use files but instead output to the console. The standard logger will output to standard out while the debug logger outputs to standard error.</para><para>Changing these last two lines to another value will create files that are used to store the log messages. All messages are appended to the file.</para><para>When using either standard error or standard out, the messages for the two different loggers will look like:</para><para><preformatted>
  gr::log :&lt;level&gt;: &lt;block alias&gt; - &lt;message&gt;
  gr::debug :&lt;level&gt;: &lt;block alias&gt; - &lt;message&gt;
</preformatted></para><para>When using a file, the only difference in the format is that the message prefix of &quot;gr::log&quot; or &quot;gr::debug&quot; is not used. Instead, the time in milliseconds from the start of the program is inserted.</para><para>Remember that a local &quot;~/.gnuradio/config.conf&quot; file can be used to override any parameter in the global file (see <ref refid="page_prefs_1prefs" kindref="member">Configuration / Preference Files</ref> for more details).</para><para>To use these loggers inside of a GNU Radio block, we use the protected data members of d_logger and d_debug_logger of gr_block and pass them to our pre-defined macros:</para><para><programlisting><codeline><highlight class="normal">GR_LOG_&lt;level&gt;(&lt;logger&gt;,<sp/>&quot;&lt;Message<sp/>to<sp/>print&gt;&quot;);</highlight></codeline>
</programlisting></para><para>Where &lt;level&gt; is one of the levels as mentioned above, &lt;logger&gt; is either d_logger or d_debug_logger, and &lt;Message to print&gt; is the message we want to output. If we wanted to output an INFO level message to the standard logger and a WARN level message to the debug logger, it would look like this:</para><para><programlisting><codeline><highlight class="normal">GR_LOG_INFO(d_logger,<sp/>&quot;Some<sp/>info<sp/>about<sp/>the<sp/>block&quot;);</highlight></codeline>
<codeline><highlight class="normal">GR_LOG_WARN(d_debug_logger,<sp/>&quot;Some<sp/>warning<sp/>about<sp/>the<sp/>block&quot;);</highlight></codeline>
</programlisting></para><para>When this is printed to wherever you are directing the output of the logger, it will look like:</para><para><preformatted>
    gr::log :INFO: &lt;block&apos;s alias&gt; - Some info about the block
    gr::debug :WARN: &lt;block&apos;s alias&gt; - Some warning about the block
</preformatted></para><para>This provides us information about where the message came from, the level of the message, and the block that generated the message. We use the concept of the block&apos;s alias which by default (i.e., unless otherwise set by the user) includes the name of the block and a unique ID to distinguish it from other blocks of the same type.</para><para>The various logging macros are defined in gr_logger.h. Here are some simple examples of using them:</para><para><programlisting><codeline><highlight class="normal">GR_LOG_DEBUG(LOG,<sp/>&quot;DEBUG<sp/>message&quot;);</highlight></codeline>
<codeline><highlight class="normal">GR_LOG_INFO(LOG,<sp/>&quot;INFO<sp/>message&quot;);</highlight></codeline>
<codeline><highlight class="normal">GR_LOG_NOTICE(LOG,<sp/>&quot;NOTICE<sp/>message&quot;);</highlight></codeline>
<codeline><highlight class="normal">GR_LOG_WARN(LOG,<sp/>&quot;WARNING<sp/>message&quot;);</highlight></codeline>
<codeline><highlight class="normal">GR_LOG_ERROR(LOG,<sp/>&quot;ERROR<sp/>message&quot;);</highlight></codeline>
<codeline><highlight class="normal">GR_LOG_CRIT(LOG,<sp/>&quot;CRIT<sp/>message&quot;);</highlight></codeline>
<codeline><highlight class="normal">GR_LOG_ALERT(LOG,<sp/>&quot;ALERT<sp/>message&quot;);</highlight></codeline>
<codeline><highlight class="normal">GR_LOG_FATAL(LOG,<sp/>&quot;FATAL<sp/>message&quot;);</highlight></codeline>
<codeline><highlight class="normal">GR_LOG_EMERG(LOG,<sp/>&quot;EMERG<sp/>message&quot;);</highlight></codeline>
</programlisting></para><para>If the logger is not enabled, then these macros become nops and do nothing (and d_logger and d_debug_logger are NULL pointers). If logging is enabled but the log4cpp library is not found, then TRACE, INFO, and NOTICE levels go to stdout and the rest to stderr.</para></sect2>
<sect2 id="page_logger_1adv_config">
<title>Advanced Configuration Options</title>
<para>If not using the simplified settings discussed above, where we can direct the logger messages to either a file or one of the standard outputs, we must use a more complicated configuration file. We do this by specifying the &quot;log_config&quot; option in the [LOG] section. The log4cpp documentation will provide more information on how configuration works and looks. Mostly, a default configuration script provided with GNU Radio can be used. After installation, the default configuration script is located at:</para><para><preformatted>
    $prefix/etc/gnuradio/gr_log_default.conf
</preformatted></para><para>For the following examples, we will assume that our local &quot;~/.gnuradio/config.conf&quot; looks like this:</para><para><programlisting><codeline><highlight class="normal">[LOG]</highlight></codeline>
<codeline><highlight class="normal">log_config<sp/>=<sp/>/opt/gr/etc/gnuadio/gr_log_default.conf</highlight></codeline>
<codeline><highlight class="normal">log_level<sp/>=<sp/>debug</highlight></codeline>
<codeline><highlight class="normal">debug_level<sp/>=<sp/>Off</highlight></codeline>
</programlisting></para><para>Inside of the default configuration file, we define the parameters for the two logger&apos;s, the standard logger the separate debug logger.</para><para>If the levels of the two loggers are specified in our configuration file, as in the above example, these levels override any levels specified in the XML file. Here, we have turned on the standard logger (d_logger) to all levels and turned off the debug logger (d_debug_logger). So even if the debug logger is used in the code, it will not actually output any information. Conversely, any level of output passed to the standard logger will output because we have turned this value to the lowest level &quot;debug.&quot;</para><para>If both an XML configuration file is set and the &quot;log_file&quot; or &quot;debug_file&quot; options are set at the same time, both systems are actually used. So you can configure file access and the pattern through the XML file while also still outputting to stdout or stderr.</para></sect2>
</sect1>
<sect1 id="page_logger_1advlog">
<title>Advanced Usage</title>
<para>The description above for using the logging facilities is specific to GNU Radio blocks. We have put the code necessary to access the debugger into the gr_block parent class to simplify access and make sure all blocks have the ability to quickly and easily use the logger.</para><para>For non gr_block-based code, we have to get some information about the logger in order to properly access it. Each logger only exists once as a singleton in the system, but we need to get a pointer to the right logger and then set it up for our local use. The following code snippet shows how to do this to get access to the standard logger, which has a root of &quot;gr_log.&quot; (access to the debug logger is similar except we would use &quot;gr_log_debug.&quot; in the GR_LOG_GETLOGGER call):</para><para><programlisting><codeline><highlight class="normal">prefs<sp/>*p<sp/>=<sp/>prefs::singleton();</highlight></codeline>
<codeline><highlight class="normal">std::string<sp/>log_file<sp/>=<sp/>p-&gt;get_string(&quot;LOG&quot;,<sp/>&quot;log_config&quot;,<sp/>&quot;&quot;);</highlight></codeline>
<codeline><highlight class="normal">std::string<sp/>log_level<sp/>=<sp/>p-&gt;get_string(&quot;LOG&quot;,<sp/>&quot;log_level&quot;,<sp/>&quot;off&quot;);</highlight></codeline>
<codeline><highlight class="normal">GR_CONFIG_LOGGER(log_file);</highlight></codeline>
<codeline><highlight class="normal">GR_LOG_GETLOGGER(LOG,<sp/>&quot;gr_log.&quot;<sp/>+<sp/>&quot;my_logger_name&quot;);</highlight></codeline>
<codeline><highlight class="normal">GR_LOG_SET_LEVEL(LOG,<sp/>log_level);</highlight></codeline>
</programlisting></para><para>This creates a pointer called LOG (which is instantiated as a log4cpp:LoggerPtr in the macro) that we can now use locally as the input to our logging macros like &apos;GR_LOG_INFO(LOG, &quot;message&quot;)&apos;.</para><sect2 id="page_logger_1using_logging">
<title>Using Logging in Out of Tree Modules</title>
<para>In order to use the logging interface in an out of tree module based on a gr_modtool template module, several CMake modifications are required. Without these changes, logging will be disabled.</para><para>GrMiscUtils.cmake module must be included in the OOT module top level CMakeLists.Texts file, and the GR_LOGGING() function provided by GrMiscUtils must be called from the same top level CMakeLists.txt file. This will set the appropriate build environment and during that process, attempt to find the log4cpp package using the FindLog4Cpp.cmake module. This module is not included in the module by gr_modtool, but is part of the GNU Radio codebase and can be copied directly into the cmake/Modules/ directory of the OOT module.</para><para>Once these CMake changes are made, the GR logging interface will function as documented on this page.</para></sect2>
</sect1>
<sect1 id="page_logger_1logPy">
<title>Logging from Python</title>
<para>The logging capability has been brought out python via swig. The configuration of the logger can be manipulated via the following calls: <programlisting><codeline><highlight class="normal">from<sp/>gnuradio<sp/>import<sp/>gr</highlight></codeline>
<codeline><highlight class="normal">gr.logger_config(filename,watch_period)<sp/><sp/>#<sp/>Configures<sp/>the<sp/>logger<sp/>with<sp/>conf<sp/>file<sp/>filename</highlight></codeline>
<codeline><highlight class="normal">names<sp/>=<sp/>gr.logger_get_names()<sp/><sp/>#<sp/>Returns<sp/>the<sp/>names<sp/>of<sp/>all<sp/>loggers</highlight></codeline>
<codeline><highlight class="normal">gr.logger_reset_config()<sp/><sp/><sp/>#<sp/>Resets<sp/>logger<sp/>config<sp/>by<sp/>removing<sp/>all<sp/>appenders</highlight></codeline>
</programlisting></para><para>Once the logger is configured you can manipulate a logger via a wrapper class <ref refid="classgr_1_1logger" kindref="compound">gr.logger()</ref>. You can isntantiate this by the following. (Reference <ref refid="logger_8h" kindref="compound">logger.h</ref> for list of methods) <programlisting><codeline><highlight class="normal">from<sp/>gnuradio<sp/>import<sp/>gr</highlight></codeline>
<codeline><highlight class="normal">log=gr.logger(&quot;nameOfLogger&quot;)</highlight></codeline>
<codeline><highlight class="normal">log.debug(&quot;Log<sp/>a<sp/>debug<sp/>message&quot;)</highlight></codeline>
<codeline><highlight class="normal">log.set_level(&quot;INFO&quot;);</highlight></codeline>
</programlisting> </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
