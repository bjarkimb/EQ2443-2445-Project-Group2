<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.11">
  <compounddef id="page_ofdm" kind="page">
    <compoundname>page_ofdm</compoundname>
    <title>OFDM</title>
    <detaileddescription>
<sect1 id="page_ofdm_1ofdm_introduction">
<title>Introduction</title>
<para>GNU Radio provides some blocks to transmit and receive OFDM-modulated signals. In the following, we assume the reader is familiar with OFDM and how it works, for an introduction to OFDM refer to standard textbooks on digital communication.</para><para>The blocks are designed in a very generic fashion. As a developer, this means that often, a desired functionality can be achieved by correct parametrization of the available blocks, but in some cases, custom blocks have to be included. The design of the OFDM components is such that adding own functionality is possible with very little friction.</para><para><ref refid="page_packet_data" kindref="compound">Packet Data Transmission</ref> has an example of how to use OFDM in a packet-based receiver.</para></sect1>
<sect1 id="page_ofdm_1ofdm_conventions">
<title>Conventions and Notations</title>
<sect2 id="page_ofdm_1ofdm_fftshift">
<title>FFT Shifting</title>
<para>In all cases where OFDM symbols are passed between blocks, the default behaviour is to FFT-Shift these symbols, i.e. that the DC carrier is in the middle (to be precise, it is on carrier <formula id="12">$\lfloor N/2 \rfloor$</formula> where N is the FFT length and carrier indexing starts at 0).</para><para>The reason for this convention is that some blocks require FFT-shifted ordering of the symbols to function (such as <ref refid="classgr_1_1digital_1_1ofdm__chanest__vcvc" kindref="compound">gr::digital::ofdm_chanest_vcvc</ref>), and for consistency&apos;s sake, this was chosen as a default for all blocks that pass OFDM symbols. Also, when viewing OFDM symbols, FFT-shifted symbols are in their natural order, i.e. as they appear in the pass band.</para></sect2>
<sect2 id="page_ofdm_1ofdm_indexing">
<title>Carrier Indexing</title>
<para>Carriers are always index starting at the DC carrier, which has the index 0 (you usually don&apos;t want to occupy this carrier). The carriers right of the DC carrier (the ones at higher frequencies) are indexed with 1 through N/2-1 (N being the FFT length again).</para><para>The carriers left of the DC carrier (with lower frequencies) can be indexed -N/2 through -1 or N/2 through N-1. Carrier indices N-1 and -1 are thus equivalent. The advantage of using negative carrier indices is that the FFT length can be changed without changing the carrier indexing.</para></sect2>
<sect2 id="page_ofdm_1ofdm_carrieralloc">
<title>Carrier and Symbol Allocation</title>
<para>Many blocks require knowledge of which carriers are allocated, and whether they carry data or pilot symbols. GNU Radio blocks uses three objects for this, typically called <computeroutput>occupied_carriers</computeroutput> (for the data symbols), <computeroutput>pilot_carriers</computeroutput> and <computeroutput>pilot_symbols</computeroutput> (for the pilot symbols).</para><para>Every one of these objects is a vector of vectors. <computeroutput>occupied_carriers</computeroutput> and <computeroutput>pilot_carriers</computeroutput> identify the position within a frame where data and pilot symbols are stored, respectively.</para><para><computeroutput>occupied_carriers</computeroutput>[0] identifies which carriers are occupied on the first OFDM symbol, <computeroutput>occupied_carriers</computeroutput>[1] does the same on the second OFDM symbol etc.</para><para>Here&apos;s an example: <programlisting><codeline><highlight class="normal">occupied_carriers<sp/>=<sp/>((-2,<sp/>-1,<sp/>1,<sp/>3),<sp/>(-3,<sp/>-1,<sp/>1,<sp/>2))</highlight></codeline>
<codeline><highlight class="normal">pilot_carriers<sp/>=<sp/>((-3,<sp/>2),<sp/>(-2,<sp/>3))</highlight></codeline>
</programlisting> Every OFDM symbol carries 4 data symbols. On the first OFDM symbol, they are on carriers -2, -1, 1 and 3. Carriers -3 and 2 are not used, so they are where the pilot symbols can be placed. On the second OFDM symbol, the occupied carriers are -3, -1, 1 and 2. The pilot symbols must thus be placed elsewhere, and are put on carriers -2 and 3.</para><para>If there are more symbols in the OFDM frame than the length of <computeroutput>occupied_carriers</computeroutput> or <computeroutput>pilot_carriers</computeroutput>, they wrap around (in this example, the third OFDM symbol uses the allocation in <computeroutput>occupied_carriers</computeroutput>[0]).</para><para>But how are the pilot symbols set? This is a valid parametrization: <programlisting><codeline><highlight class="normal">pilot_symbols<sp/>=<sp/>((-1,<sp/>1j),<sp/>(1,<sp/>-1j),<sp/>(-1,<sp/>1j),<sp/>(-1j,<sp/>1))</highlight></codeline>
</programlisting></para><para>The position of these symbols are thos in <computeroutput>pilot_carriers</computeroutput>. So on the first OFDM symbol, carrier -3 will transmit a -1, and carrier 2 will transmit a 1j. Note that <computeroutput>pilot_symbols</computeroutput> is longer than <computeroutput>pilot_carriers</computeroutput> in this example<ndash/> this is valid, the symbols in <computeroutput>pilot_symbols</computeroutput>[2] will be mapped according to <computeroutput>pilot_carriers</computeroutput>[0].</para></sect2>
</sect1>
<sect1 id="page_ofdm_1ofdm_detectsync">
<title>Detection and Synchronisation</title>
<para>Before anything happens, an OFDM frame must be detected, the beginning of OFDM symbols must be identified, and frequency offset must be estimated.</para></sect1>
<sect1 id="page_ofdm_1ofdm_tx">
<title>Transmitting</title>
<para><image type="html" name="ofdm_tx_core.png">Core elements of an OFDM transmitter</image>
 This image shows a very simple example of a transmitter. It is assumed that the input is a stream of complex scalars with a length tag, i.e. the transmitter will work on one frame at a time.</para><para>The first block is the carrier allocator (<ref refid="classgr_1_1digital_1_1ofdm__carrier__allocator__cvc" kindref="compound">gr::digital::ofdm_carrier_allocator_cvc</ref>). This sorts the incoming complex scalars onto OFDM carriers, and also places the pilot symbols onto the correct positions. There is also the option to pass OFDM symbols which are prepended in front of every frame (i.e. preamble symbols). These can be used for detection, synchronisation and channel estimation.</para><para>The carrier allocator outputs OFDM symbols (i.e. complex vectors of FFT length). These must be converted to time domain signals before continuing, which is why they are piped into an (I)FFT block. Note that because all the OFDM symbols are treated in the shifted form, the IFFT block must be shifting as well.</para><para>Finally, the cyclic prefix is added to the OFDM symbols. The <ref refid="classgr_1_1digital_1_1ofdm__cyclic__prefixer" kindref="compound">gr::digital::ofdm_cyclic_prefixer</ref> can also perform pulse shaping on the OFDM symbols (raised cosine flanks in the time domain).</para></sect1>
<sect1 id="page_ofdm_1ofdm_rx">
<title>Receiving</title>
<para>On the receiver side, some more effort is necessary. The following flow graph assumes that the input starts at the beginning of an OFDM frame and is prepended with a Schmidl &amp; Cox preamble for coarse frequency correction and channel estimation. Also assumed is that the fine frequency offset is already corrected and that the cyclic prefix has been removed. The latter can be achieved by a <ref refid="classgr_1_1digital_1_1header__payload__demux" kindref="compound">gr::digital::header_payload_demux</ref>, the former can be done using a gr::digital::ofdm_sync_sc_cc.</para><para><image type="html" name="ofdm_rx_core.png">Core elements of an OFDM receiver</image>
 First, an FFT shifts the OFDM symbols into the frequency domain, where the signal processing is performed (the OFDM frame is thus in the memory in matrix form). It is passed to a block that uses the preambles to perform channel estimation and coarse frequency offset. Both of these values are added to the output stream as tags; the preambles are then removed from the stream and not propagated.</para><para>Note that this block does not correct the OFDM frame. Both the coarse frequency offset correction and the equalizing (using the initial channel state estimate) are done in the following block, <ref refid="classgr_1_1digital_1_1ofdm__frame__equalizer__vcvc" kindref="compound">gr::digital::ofdm_frame_equalizer_vcvc</ref>. The interesting property about this block is that it uses a <ref refid="classgr_1_1digital_1_1ofdm__equalizer__base" kindref="compound">gr::digital::ofdm_equalizer_base</ref> derived object to perform the actual equalization.</para><para>The last block in the frequency domain is the <ref refid="classgr_1_1digital_1_1ofdm__serializer__vcc" kindref="compound">gr::digital::ofdm_serializer_vcc</ref>, which is the inverse block to the carrier allocator. It plucks the data symbols from the <computeroutput>occupied_carriers</computeroutput> and outputs them as a stream of complex scalars. These can then be directly converted to bits, or passed to a forward error correction decoder. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
