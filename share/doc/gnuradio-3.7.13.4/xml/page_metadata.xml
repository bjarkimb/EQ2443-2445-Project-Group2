<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.11">
  <compounddef id="page_metadata" kind="page">
    <compoundname>page_metadata</compoundname>
    <title>Metadata Information</title>
    <detaileddescription>
<sect1 id="page_metadata_1metadata_introduction">
<title>Introduction</title>
<para>Metadata files have extra information in the form of headers that carry metadata about the samples in the file. Raw, binary files carry no extra information and must be handled delicately. Any changes in the system state such as a receiver&apos;s sample rate or frequency are not conveyed with the data in the file itself. Headers solve this problem.</para><para>We write metadata files using <ref refid="classgr_1_1blocks_1_1file__meta__sink" kindref="compound">gr::blocks::file_meta_sink</ref> and read metadata files using <ref refid="classgr_1_1blocks_1_1file__meta__source" kindref="compound">gr::blocks::file_meta_source</ref>.</para><para>Metadata files have headers that carry information about a segment of data within the file. The header structure is described in detail in the next section. A metadata file always starts with a header that describes the basic structure of the data. It contains information about the item size, data type, if it&apos;s complex, the sample rate of the segment, the time stamp of the first sample of the segment, and information regarding the header size and segment size.</para><para>The first static portion of the header file contains the following information.</para><para><itemizedlist>
<listitem><para>version: (char) version number (usually set to METADATA_VERSION)</para></listitem><listitem><para>rx_rate: (double) Stream&apos;s sample rate</para></listitem><listitem><para>rx_time: (<ref refid="namespacepmt_1ab4b70d9293452eb74dd07c670e6811fa" kindref="member">pmt::pmt_t</ref> pair - (uint64_t, double)) Time stamp (format from UHD)</para></listitem><listitem><para>size: (int) item size in bytes - reflects vector length if any</para></listitem><listitem><para>type: (int) data type (enum below)</para></listitem><listitem><para>cplx: (bool) true if data is complex</para></listitem><listitem><para>strt: (uint64_t) start of data relative to current header</para></listitem><listitem><para>bytes: (uint64_t) size of following data segment in bytes</para></listitem></itemizedlist>
</para><para>An optional extra section of the header stores information in any received tags. The two main tags associated with headers are:</para><para><itemizedlist>
<listitem><para>rx_rate: the sample rate of the stream.</para></listitem><listitem><para>rx_time: the time stamp of the first item in the segment.</para></listitem></itemizedlist>
</para><para>These tags were inspired by the UHD tag format.</para><para>The header gives enough information to process and handle the data. One cautionary note, though, is that the data type should never change within a file. There should be very little need for this, because GNU Radio blocks can only set the data type of their IO signatures in the constructor, so changes in the data type afterward will not be recognized.</para><para>We also have an extra header segment that is optional. This can be loaded up at the beginning by the user specifying some extra metadata that should be transmitted along with the data. It also grows whenever it sees a stream tag, so the dictionary will contain any key:value pairs out of tags from the flowgraph.</para><sect2 id="page_metadata_1metadata_types">
<title>Types of Metadata Files</title>
<para>GNU Radio currently supports two types of metadata files:</para><para><itemizedlist>
<listitem><para>inline: headers are inline with the data in the same file.</para></listitem><listitem><para>detached: headers are in a separate header file from the data.</para></listitem></itemizedlist>
</para><para>The inline method is the standard version. When a detached header is used, the headers are simply inserted back-to-back in the detached header file. The dat file, then, is the standard raw binary format with no interruptions in the data.</para></sect2>
<sect2 id="page_metadata_1metadata_updating">
<title>Updating Headers</title>
<para>While there is always a header that starts a metadata file, they are updated throughout as well. There are two events that trigger a new header. We define a segment as the unit of data associated with the last header.</para><para>The first event that will trigger a new header is when enough samples have been written for the given segment. This number is defined as the maximum segment size and is a parameter we pass to the file_meta_sink. It defaults to 1 million items (items, not bytes). When that number of items is reached, a new header is generated and a new segment is started. This makes it easier for us to manipulate the data later and helps protect against catastrophic data loss.</para><para>The second event to trigger a new segment is if a new tag is observed. If the tag is a standard tag in the header, the header value is updated, the header and current extras are written to file, and the segment begins again. If a tag from the extras is seen, the value associated with that tag is updated; and if a new tag is seen, a new key:value pair are added to the extras dictionary.</para><para>When new tags are seen, we generate a new segment so that we make sure that all samples in that segment are defined by the header. If the sample rate changes, we create a new segment where all of the new samples are at that new rate. Also, in the case of UHD devices, if a segment loss is observed, it will generate a new timestamp as a tag of &apos;rx_time&apos;. We create a new file segment that reflects this change to keep the sample times exact.</para></sect2>
<sect2 id="page_metadata_1metadata_implementation">
<title>Implementation</title>
<para>Metadata files are created using <ref refid="classgr_1_1blocks_1_1file__meta__sink" kindref="compound">gr::blocks::file_meta_sink</ref>. The default behavior is to create a single file with inline headers as metadata. An option can be set to switch to detached header mode.</para><para>Metadata files are read into a flowgraph using <ref refid="classgr_1_1blocks_1_1file__meta__source" kindref="compound">gr::blocks::file_meta_source</ref>. This source reads a metadata file, inline by default with a settable option to use detached headers. The data from the segments is converted into a standard streaming output. The &apos;rx_rate&apos; and &apos;rx_time&apos; and all key:value pairs in the extra header are converted into tags and added to the stream tags interface.</para></sect2>
</sect1>
<sect1 id="page_metadata_1metadata_structure">
<title>Structure</title>
<para>The file metadata consists of a static mandatory header and a dynamic optional extras header. Each header is a separate PMT dictionary. Headers are created by building a PMT dictionary (<ref refid="namespacepmt_1aba10563e3ab43b8d52f9cb13132047cf" kindref="member">pmt::make_dict</ref>) of key:value pairs, then the dictionary is serialized into a string to be written to file. The header is always the same length that is predetermined by the version of the header (this must be known already). The header will then indicate if there is extra data to be extracted as a separate serialized dictionary.</para><para>To work with the PMTs for creating and extracting header information, we use PMT operators. For example, we create a simplified version of the header in C++ like this:</para><para><programlisting><codeline><highlight class="normal">const<sp/>char<sp/>METADATA_VERSION<sp/>=<sp/>0x0;</highlight></codeline>
<codeline><highlight class="normal">pmt::pmt_t<sp/>header;</highlight></codeline>
<codeline><highlight class="normal">header<sp/>=<sp/>pmt::make_dict();</highlight></codeline>
<codeline><highlight class="normal">header<sp/>=<sp/>pmt::dict_add(header,<sp/>pmt::mp(&quot;version&quot;),<sp/>pmt::mp(METADATA_VERSION));</highlight></codeline>
<codeline><highlight class="normal">header<sp/>=<sp/>pmt::dict_add(header,<sp/>pmt::mp(&quot;rx_rate&quot;),<sp/>pmt::mp(samp_rate));</highlight></codeline>
<codeline><highlight class="normal">std::string<sp/>hdr_str<sp/>=<sp/>pmt::serialize_str(header);</highlight></codeline>
</programlisting></para><para>The call to <ref refid="namespacepmt_1a15e351077c14dcba7cb982951bbbd05b" kindref="member">pmt::dict_add</ref> adds a new key:value pair to the dictionary. Notice that it both takes and returns the &apos;header&apos; variable. This is because we are actually creating a new dictionary with this function, so we just assign it to the same variable.</para><para>The &apos;mp&apos; functions are convenience functions provided by the PMT library. They interpret the data type of the value being inserted and call the correct &apos;pmt::from_xxx&apos; function. For more direct control over the data type, see PMT functions in <ref refid="pmt_8h" kindref="compound">pmt.h</ref>, such as <ref refid="namespacepmt_1afc16836b99dd09140139b78c7dfbba7e" kindref="member">pmt::from_uint64</ref> or <ref refid="namespacepmt_1ad20c287c509e8470d03d1c8e97fea12d" kindref="member">pmt::from_double</ref>.</para><para>We finish this off by using <ref refid="namespacepmt_1a1d54fe01f68a0452b722c8eac6b957b4" kindref="member">pmt::serialize_str</ref> to convert the PMT dictionary into a specialized string format that makes it easy to write to a file.</para><para>The header is always METADATA_HEADER_SIZE bytes long and a metadata file always starts with a header. So to extract the header from a file, we need to read in this many bytes from the beginning of the file and deserialize it. An important note about this is that the deserialize function must operate on a std::string. The serialized format of a dictionary contains null characters, so normal C character arrays (e.g., &apos;char *s&apos;) get confused.</para><para>Assuming that &apos;std::string str&apos; contains the full string as read from a file, we can access the dictionary in C++ like this:</para><para><programlisting><codeline><highlight class="normal">pmt::pmt_t<sp/>hdr<sp/>=<sp/>pmt::deserialize_str(str);</highlight></codeline>
<codeline><highlight class="normal">if(pmt::dict_has_key(hdr,<sp/>pmt::string_to_symbol(&quot;strt&quot;)))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pmt::pmt_t<sp/>r<sp/>=<sp/>pmt::dict_ref(hdr,<sp/>pmt::string_to_symbol(&quot;strt&quot;),<sp/>pmt::PMT_NIL);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>uint64_t<sp/>seg_start<sp/>=<sp/>pmt::to_uint64(r);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>uint64_t<sp/>extra_len<sp/>=<sp/>seg_start<sp/>-<sp/>METADATA_HEADER_SIZE;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>This example first deserializes the string into a PMT dictionary again. This will throw an error if the string is malformed and cannot be deserialized correctly. We then want to get access to the item with key &apos;strt&apos;. As the next subsection will show, this value indicates at which byte the data segment starts. We first check to make sure that this key exists in the dictionary. If not, our header does not contain the correct information and we might want to handle this as an error.</para><para>Assuming the header is properly formatted, we then get the particular item referenced by the key &apos;strt&apos;. This is a uint64_t, so we use the PMT function to extract and convert this value properly. We now know if we have an extra header in the file by looking at the difference between &apos;seg_start&apos; and the static header size, METADATA_HEADER_SIZE. If the &apos;extra_len&apos; is greater than 0, we know we have an extra header that we can process. Moreover, this also tells us the size of the serialized PMT dictionary in bytes, so we can easily read this many bytes from the file. We can then deserialize and parse this header just like the first.</para><sect2 id="page_metadata_1metadata_header">
<title>Header Information</title>
<para>The header is a PMT dictionary with a known structure. This structure may change, but we version the headers, so all headers of version X must be the same length and structure. As of now, we only have version 0 headers, which look like the following:</para><para><itemizedlist>
<listitem><para>version: (char) version number (usually set to METADATA_VERSION)</para></listitem><listitem><para>rx_rate: (double) Stream&apos;s sample rate</para></listitem><listitem><para>rx_time: (<ref refid="namespacepmt_1ab4b70d9293452eb74dd07c670e6811fa" kindref="member">pmt::pmt_t</ref> pair - (uint64_t, double)) Time stamp (format from UHD)</para></listitem><listitem><para>size: (int) item size in bytes - reflects vector length if any.</para></listitem><listitem><para>type: (int) data type (enum below)</para></listitem><listitem><para>cplx: (bool) true if data is complex</para></listitem><listitem><para>strt: (uint64_t) start of data relative to current header</para></listitem><listitem><para>bytes: (uint64_t) size of following data segment in bytes</para></listitem></itemizedlist>
</para><para>The data types are indicated by an integer value from the following enumeration type:</para><para><programlisting><codeline><highlight class="normal">enum<sp/>gr_file_types<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GR_FILE_BYTE=0,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GR_FILE_CHAR=0,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GR_FILE_SHORT=1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GR_FILE_INT,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GR_FILE_LONG,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GR_FILE_LONG_LONG,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GR_FILE_FLOAT,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>GR_FILE_DOUBLE,</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="page_metadata_1metadata_extras">
<title>Extras Information</title>
<para>The extras section is an optional segment of the header. If &apos;strt&apos; == METADATA_HEADER_SIZE, then there is no extras. Otherwise, it is simply a PMT dictionary of key:value pairs. The extras header can contain anything and can grow while a program is running.</para><para>We can insert extra data into the header at the beginning if we wish. All we need to do is use the <ref refid="namespacepmt_1a15e351077c14dcba7cb982951bbbd05b" kindref="member">pmt::dict_add</ref> function to insert our hand-made metadata. This can be useful to add our own markers and information.</para><para>The main role of the extras header, though, is as a container to hold any stream tags. When a stream tag is observed coming in, the tag&apos;s key and value are added to the dictionary. Like a standard dictionary, any time a key already exists, the value will be updated. If the key does not exist, a new entry is created and the new key:value pair are added together. So any new tags that the file metadata sink sees will add to the dictionary. It is therefore important to always check the &apos;strt&apos; value of the header to see if the length of the extras dictionary has changed at all.</para><para>When reading out data from the extras, we do not necessarily know the data type of the PMT value. The key is always a PMT symbol, but the value can be any other PMT type. There are PMT functions that allow us to query the PMT to test if it is a particular type. We also have the ability to do <ref refid="namespacepmt_1acf4beefce8c6c5c70bdce4e246a54886" kindref="member">pmt::print</ref> on any PMT object to print it to screen. Before converting from a PMT to its natural data type, it is necessary to know the data type.</para></sect2>
</sect1>
<sect1 id="page_metadata_1metadata_utilities">
<title>Utilities</title>
<para>GNU Radio comes with a couple of utilities to help in debugging and manipulating metadata files. There is a general parser in Python that will convert the PMT header and extra header into Python dictionaries. This utility is:</para><para><itemizedlist>
<listitem><para>gr-blocks/python/parse_file_metadata.py</para></listitem></itemizedlist>
</para><para>This program is installed into the Python directory under the &apos;gnuradio&apos; module, so it can be accessed with:</para><para><programlisting><codeline><highlight class="normal">from<sp/>gnuradio.blocks<sp/>import<sp/>parse_file_metadata</highlight></codeline>
</programlisting></para><para>It defines HEADER_LENGTH as the static length of the metadata header size. It also has dictionaries that can be used to convert from the file type to a string (ftype_to_string) and one to convert from the file type to the size of the data type in bytes (ftype_to_size).</para><para>The &apos;parse_header&apos; takes in a PMT dictionary, parses it, and returns a Python dictionary. An optional &apos;VERBOSE&apos; bool can be set to print the information to standard out.</para><para>The &apos;parse_extra_dict&apos; is similar in that it converts from a PMT dictionary to a Python dictionary. The values are kept in their PMT format since we do not necessarily know the native data type.</para><para>A program called &apos;gr_read_file_metadata&apos; is installed into the path and can be used to read out all header information from a metadata file. This program is just called with the file name as the first command-line argument. An option &apos;-D&apos; will handle detached header files where the file of headers is expected to be the file name of the data with &apos;.hdr&apos; appended to it.</para></sect1>
<sect1 id="page_metadata_1metadata_examples">
<title>Examples</title>
<para>Examples are located in:</para><para><itemizedlist>
<listitem><para>gr-blocks/examples/metadata</para></listitem></itemizedlist>
</para><para>Currently, there are a few GRC example programs.</para><para><itemizedlist>
<listitem><para>file_metadata_sink: create a metadata file from UHD samples.</para></listitem><listitem><para>file_metadata_source: read the metadata file as input to a simple graph.</para></listitem><listitem><para>file_metadata_vector_sink: create a metadata file from UHD samples.</para></listitem><listitem><para>file_metadata_vector_source: read the metadata file as input to a simple graph.</para></listitem></itemizedlist>
</para><para>The file sink example can be switched to use a signal source instead of a UHD source, but no extra tagged data is used in this mode.</para><para>The file source example pushes the data stream to a new raw file while a tag debugger block prints out any tags observed in the metadata file. A QT GUI time sink is used to look at the signal as well.</para><para>The versions with &apos;vector&apos; in the name are similar except they use vectors of data.</para><para>The following shows a simple way of creating extra metadata for a metadata file. This example is just showing how we can insert a date into the metadata to keep track of it later. The date in this case is encoded as a vector of uint16 with [day, month, year].</para><para><programlisting><codeline><highlight class="normal">import<sp/>pmt</highlight></codeline>
<codeline><highlight class="normal">from<sp/>gnuradio<sp/>import<sp/>blocks</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">key<sp/>=<sp/>pmt.intern(&quot;date&quot;)</highlight></codeline>
<codeline><highlight class="normal">val<sp/>=<sp/>pmt.init_u16vector(3,<sp/>[13,12,2012])</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">extras<sp/>=<sp/>pmt.make_dict()</highlight></codeline>
<codeline><highlight class="normal">extras<sp/>=<sp/>pmt.dict_add(extras,<sp/>key,<sp/>val)</highlight></codeline>
<codeline><highlight class="normal">extras_str<sp/>=<sp/>pmt.serialize_str(extras)</highlight></codeline>
<codeline><highlight class="normal">self.sink<sp/>=<sp/>blocks.file_meta_sink(gr.sizeof_gr_complex,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;/tmp/metadat_file.out&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>samp_rate,<sp/>1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>blocks.GR_FILE_FLOAT,<sp/>True,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1000000,<sp/>extra_str,<sp/>False)</highlight></codeline>
</programlisting> </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
