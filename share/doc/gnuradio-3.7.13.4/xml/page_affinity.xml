<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.11">
  <compounddef id="page_affinity" kind="page">
    <compoundname>page_affinity</compoundname>
    <title>Block Thread Affinity and Priority</title>
    <detaileddescription>
<sect1 id="page_affinity_1affinity">
<title>Block Thread Affinity</title>
<para>In the thread-per-block scheduler, you can set the block&apos;s core affinity. Each block can be pinned to a group cores or be set back to use the standard kernel scheduler.</para><para>The implementation is done by adding new functions to the threading section of the gnuradio-runtime library:</para><para><programlisting><codeline><highlight class="normal">gr::thread::gr_thread_t<sp/>get_current_thread_id();</highlight></codeline>
<codeline><highlight class="normal">void<sp/>thread_bind_to_processor(unsigned<sp/>int<sp/>n);</highlight></codeline>
<codeline><highlight class="normal">void<sp/>thread_bind_to_processor(const<sp/>std::vector&lt;unsigned<sp/>int&gt;<sp/>&amp;mask);</highlight></codeline>
<codeline><highlight class="normal">void<sp/>thread_bind_to_processor(gr::thread::gr_thread_t<sp/>thread,<sp/>unsigned<sp/>int<sp/>n);</highlight></codeline>
<codeline><highlight class="normal">void<sp/>thread_bind_to_processor(gr::thread::gr_thread_t<sp/>thread,<sp/>const<sp/>std::vector&lt;unsigned<sp/>int&gt;<sp/>&amp;mask);</highlight></codeline>
<codeline><highlight class="normal">void<sp/>thread_unbind();</highlight></codeline>
<codeline><highlight class="normal">void<sp/>thread_unbind(gr::thread::gr_thread_t<sp/>thread);</highlight></codeline>
</programlisting></para><para>The ability to set a thread&apos;s affinity to a core or groups of cores is not implemented in the Boost thread library, and so we have made our own portability library. In particular, the <ref refid="namespacegr_1_1thread_1aa33c619fe30adea573dec1d14ae7ff53" kindref="member">gr::thread::gr_thread_t</ref> type is defined as the thread type for the given system. The other functions are designed to be portable as well by calling the specific implementation for the thread affinity for a particular platform.</para><para>There are functions to set a thread to a group of cores. If the thread is not given, the current thread is used. If a single number is passed, only that core is set (this is equivalent to a core mask with just a single value).</para><para>Similarly, there are functions to unset the affinity. This practically implements the setting of the thread&apos;s affinity to all possible cores. Again, the function that does not take a thread argument unsets the affinity for the current thread.</para><para>NOTE: Not available on OSX.</para><sect2 id="page_affinity_1affinity_api">
<title>GNU Radio Block API</title>
<para>Each block has two new data members:</para><para><itemizedlist>
<listitem><para>threaded: a boolean value that is true if the block is attached to a thread.</para></listitem><listitem><para>thread: a <ref refid="namespacegr_1_1thread_1aa33c619fe30adea573dec1d14ae7ff53" kindref="member">gr::thread::gr_thread_t</ref> handle to the block&apos;s thread.</para></listitem></itemizedlist>
</para><para>A block can set and unset its affinity at any time using the following member functions:</para><para><itemizedlist>
<listitem><para><ref refid="classgr_1_1block_1a05ad2ae50b0f7c922add44e74d9603b8" kindref="member">gr::block::set_processor_affinity(const std::vector&lt;int&gt; &amp;mask)</ref></para></listitem><listitem><para><ref refid="classgr_1_1block_1ac077773948a5f55b826dd638e1ed3863" kindref="member">gr::block::unset_processor_affinity()</ref></para></listitem></itemizedlist>
</para><para>Where <computeroutput>mask</computeroutput> is a vector of core numbers to set the thread&apos;s affinity to.</para><para>The current core affinity can be retrieved using the member function:</para><para><itemizedlist>
<listitem><para><ref refid="classgr_1_1block_1a3b37bd70477161aa97d1e868ff2b20d9" kindref="member">gr::block::processor_affinity()</ref></para></listitem></itemizedlist>
</para><para>When set before the flowgraph is started, the scheduler will set the thread&apos;s affinity when it is started. When already running, the block&apos;s affinity will be immediately set.</para></sect2>
<sect2 id="page_affinity_1affinity_api_hier">
<title>Setting Affinity for a gr::hier_block2</title>
<para>A hierarchical block (<ref refid="classgr_1_1hier__block2" kindref="compound">gr::hier_block2</ref>) also has a concept of setting the block thread affinity. Because the hierarchical block itself does no work and just encapsulates a set of blocks, setting the hierarchical block&apos;s affinity individually sets all blocks inside it to that affinity setting.</para><para>The <ref refid="classgr_1_1hier__block2" kindref="compound">gr::hier_block2</ref> class supports the same API interface to the block thread affinity:</para><para><itemizedlist>
<listitem><para><ref refid="classgr_1_1hier__block2_1a8291a79bc15ee093482739ec01a8c27c" kindref="member">gr::hier_block2::set_processor_affinity(const std::vector&lt;int&gt; &amp;mask)</ref></para></listitem><listitem><para><ref refid="classgr_1_1hier__block2_1a5c7f8d08d76faea2999ff66c648b2da3" kindref="member">gr::hier_block2::unset_processor_affinity()</ref></para></listitem><listitem><para><ref refid="classgr_1_1hier__block2_1ae061dc0b8b82faba2dd13738e7a7ae0c" kindref="member">gr::hier_block2::processor_affinity()</ref></para></listitem></itemizedlist>
</para><para>Setting and unsetting the affinity does so recursively for every block in the hierarchical block. It is of course possible to individually set the affinity to any block underneath the hierarchical block. However, in this case, note that when asking for the current affinity value using &apos;processor_affinity()&apos;, the code returns the current processor affinity value of only the first block.</para></sect2>
<sect2 id="page_affinity_1affinity_api_grc">
<title>GRC Access</title>
<para>GRC supports the setting of the thread core affinity in a block&apos;s options. Each block now has a field &apos;Core Affinity&apos; that accepts a vector (list) of integers and sets the affinity after the block is constructed.</para><para>Note that GRC does not provide a callback function for changing the thread core affinity while the flowgraph is running.</para></sect2>
</sect1>
<sect1 id="page_affinity_1priority_api">
<title>Setting Thread Priority</title>
<para>Similarly to setting the core affinity for a given block, we can also set the thread priority. This concept adds three new function calls to all blocks:</para><para><itemizedlist>
<listitem><para><ref refid="classgr_1_1block_1a83e0fd5c4db199e6e6f2fc75cdfb5dfa" kindref="member">gr::block::set_thread_priority(int priority)</ref>: Sets the current thread priority. </para></listitem>
<listitem><para><ref refid="classgr_1_1block_1a099f578878243499d63846bbee61979a" kindref="member">gr::block::active_thread_priority()</ref>: Gets the active priority for the thread. </para></listitem>
<listitem><para><ref refid="classgr_1_1block_1a585b831aea5775730931d7fb9e6e8253" kindref="member">gr::block::thread_priority()</ref>: Gets the stored thread priority.</para></listitem>
</itemizedlist>
The range of the thread priority might be system dependent, so look to your system/OS documentation. Linux specifies this range in <bold>sched_setscheduler</bold> as a value between 1 and 99 where 1 is the lowest priority and 99 is the highest. POSIX systems can retrieve these min and max values using <bold>sched_get_priority_min</bold> and <bold>sched_get_priority_max</bold> and may only allow 32 distinct values to be set.</para><para>NOTE: Not available on Windows or OSX. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
