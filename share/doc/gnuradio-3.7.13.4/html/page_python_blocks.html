<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>GNU Radio Manual and C++ API Reference: Python Blocks</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gnuradio_logo_icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GNU Radio Manual and C++ API Reference
   &#160;<span id="projectnumber">3.7.13.4</span>
   </div>
   <div id="projectbrief">The Free &amp; Open Software Radio Ecosystem</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_python_blocks.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Python Blocks </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>How to create blocks in Python</p>
<h1><a class="anchor" id="pyblocks_streaming"></a>
Streaming Data Blocks</h1>
<p>We create blocks in Python very much like we would in C++, just with more Python. Figure out which type of block you want to create:</p>
<ul>
<li>general block (<a class="el" href="classgr_1_1basic__block.html" title="The abstract base class for all signal processing blocks.Basic blocks are the bare abstraction of an ...">gr.basic_block</a>) </li>
<li>synchronous block (<a class="el" href="classgr_1_1sync__block.html" title="synchronous 1:1 input to output with historyOverride work to provide the signal processing implementa...">gr.sync_block</a>) </li>
<li>decimator (<a class="el" href="classgr_1_1sync__decimator.html" title="synchronous N:1 input to output with historyOverride work to provide the signal processing implementa...">gr.sync_decimator</a>) </li>
<li>interpolator (<a class="el" href="classgr_1_1sync__interpolator.html" title="synchronous 1:N input to output with historyOverride work to provide the signal processing implementa...">gr.sync_interpolator</a>)</li>
</ul>
<p>The block class inherits from one of these base classes, and then in defining the parent class, we set the I/O signature. However, unlike in C++ where we use the <a class="el" href="classgr_1_1io__signature.html" title="i/o signature for input and output ports. ">gr::io_signature</a> class, here we can just create a Python list of the I/O data sizes using numpy data types:</p>
<ul>
<li>numpy.int8 </li>
<li>numpy.int16 </li>
<li>numpy.int32 </li>
<li>numpy.float32 </li>
<li>numpy.float64</li>
</ul>
<p>Like a normal C++ version of the block, we then create and initialize any variables in the constructor, define any setters and getters, and create the work function. The prototype for the work function is quite simple:</p>
<div class="fragment"><div class="line">def work(<span class="keyword">self</span>, input_items, output_items)</div></div><!-- fragment --><p>The input_items and output_items are lists of lists. The input_items contains a vector of input samples for every input stream, and the output_items is a vector for each output stream where we can place items. Then length of output_items[0] is equivalent to the noutput_items concept we are so familiar with from the C++ blocks.</p>
<p>Following is an example Python block that adds two input streams together. This block is used in the qa_block_gateway.py test code.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>add_2_f32_1_f32(gr.sync_block):</div><div class="line">    def __init__(self):</div><div class="line">        gr.sync_block.__init__(</div><div class="line">            self,</div><div class="line">            name = &quot;add 2 f32&quot;,</div><div class="line">            in_sig = [numpy.float32, numpy.float32],</div><div class="line">            out_sig = [numpy.float32],</div><div class="line">        )</div><div class="line"></div><div class="line">    def work(self, input_items, output_items):</div><div class="line">        output_items[0][:] = input_items[0] + input_items[1]</div><div class="line">        return len(output_items[0])</div></div><!-- fragment --><p>The block defines two input floating point streams by setting in_sig to "[numpy.float32, numpy.float32]" and a single output float stream in out_sig of "[numpy.float32]."</p>
<p>The work function then just adds the two input streams together. The streams are input_items[0] and input_items[1]. The block still returns the concept of noutput_items like we use in C++, only we get it here by getting len(output_items[0]). Because this is a sync_block, we also know that the size of the input_items for both streams is the same as the size of the output_items vector.</p>
<h1><a class="anchor" id="pyblocks_tags"></a>
Using Stream Tags</h1>
<p>Python blocks have access to the stream tag system like their C++ counterparts. The interface is almost identical except they behave just a bit more like we would expect in Python.</p>
<p>To add tags to the data stream, we use the add_item_tag function:</p>
<div class="fragment"><div class="line">def work(<span class="keyword">self</span>, input_items, output_items):</div><div class="line">    ....</div><div class="line">    add_item_tag(which_output, abs_offset,</div><div class="line">                 key, value, srcid)</div><div class="line">    ....</div></div><!-- fragment --><p>The abs_offset is an integer of the sample that the tag is attached to, and key and value are both PMTs to set the key:value pair of the tag information, and the srcid is an optional PMT to define the source of the block that generate the tag.</p>
<p>We then can get tags using either the get_tags_in_range or get_tags_in_window. Again, like their C++ counter parts, the get_tags_in_range uses the absolute item offset numbering (using nitems_read) while the get_tags_in_window uses relative offsets within the current window of items available to the work function. The main difference from the C++ function is that instead of having the first argument be a vector where the tags are stored, the Python version just returns a list of tags. We would use it like this:</p>
<div class="fragment"><div class="line">def work(<span class="keyword">self</span>, input_items, output_items):</div><div class="line">    ....</div><div class="line">    tags = get_tags_in_window(which_input, rel_start, rel_end)</div><div class="line">    ....</div></div><!-- fragment --><h1><a class="anchor" id="pyblocks_msgs"></a>
Using Message Passing</h1>
<p>Again, like their C++ counterparts, Python blocks can use the asynchronous message passing interface. We define output message handlers using:</p>
<div class="fragment"><div class="line"><span class="keyword">self</span>.message_port_register_out(<a class="code" href="namespacepmt.html">pmt</a>.intern(<span class="stringliteral">&quot;&lt;port name&gt;&quot;</span>))</div></div><!-- fragment --><p>We can then post messages to this using the message_port_pub function:</p>
<div class="fragment"><div class="line"><span class="keyword">self</span>.message_port_pub(<a class="code" href="namespacepmt.html">pmt</a>.intern(<span class="stringliteral">&quot;&lt;port name&gt;&quot;</span>), &lt;<a class="code" href="namespacepmt.html">pmt</a> message&gt;)</div></div><!-- fragment --><p>We then register input messages and handlers in similar ways:</p>
<div class="fragment"><div class="line"><span class="keyword">self</span>.message_port_register_in(<a class="code" href="namespacepmt.html">pmt</a>.intern(<span class="stringliteral">&quot;&lt;port name&gt;&quot;</span>))</div><div class="line"><span class="keyword">self</span>.set_msg_handler(<a class="code" href="namespacepmt.html">pmt</a>.intern(<span class="stringliteral">&quot;&lt;port name&gt;&quot;</span>), &lt;msg handler <span class="keyword">function</span>&gt;)</div></div><!-- fragment --><p>Putting this together below is a very simple example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>msg_block(gr.basic_block):</div><div class="line">    def __init__(self):</div><div class="line">        gr.basic_block.__init__(</div><div class="line">            self,</div><div class="line">            name=&quot;msg_block&quot;,</div><div class="line">            in_sig=None,</div><div class="line">            out_sig=None)</div><div class="line"></div><div class="line">        self.message_port_register_out(pmt.intern(&#39;msg_out&#39;))</div><div class="line">        self.message_port_register_in(pmt.intern(&#39;msg_in&#39;))</div><div class="line">        self.set_msg_handler(pmt.intern(&#39;msg_in&#39;), self.handle_msg)</div><div class="line"></div><div class="line">    def handle_msg(self, msg):</div><div class="line">        self.message_port_pub(pmt.intern(&#39;msg_out&#39;),</div><div class="line">                              pmt.intern(&#39;message received!&#39;))</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
