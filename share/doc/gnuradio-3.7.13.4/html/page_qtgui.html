<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>GNU Radio Manual and C++ API Reference: QT Graphical User Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gnuradio_logo_icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GNU Radio Manual and C++ API Reference
   &#160;<span id="projectnumber">3.7.13.4</span>
   </div>
   <div id="projectbrief">The Free &amp; Open Software Radio Ecosystem</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_qtgui.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">QT Graphical User Interface </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="qtgui_introduction"></a>
Introduction</h1>
<p>This is the gr-qtgui package. It contains various QT-based graphical user interface blocks that add graphical sinks to a GNU Radio flowgraph. The Python namespaces is in gnuradio.qtgui, which would be normally imported as:</p>
<div class="fragment"><div class="line">from <a class="code" href="namespacegnuradio.html">gnuradio</a> <span class="keyword">import</span> qtgui</div></div><!-- fragment --><p>See the Doxygen documentation for details about the blocks available in this package. The relevant blocks are listed in the <a class="el" href="group__qtgui__blk.html">QT Graphical Interfaces</a> group.</p>
<p>A quick listing of the details can be found in Python after importing by using:</p>
<div class="fragment"><div class="line">help(qtgui)</div></div><!-- fragment --><h2><a class="anchor" id="qtgui_blocks"></a>
Blocks</h2>
<p>There are a number of available QTGUI blocks for different plotting purposes. These include:</p>
<ul>
<li>Time Domain (<a class="el" href="classgr_1_1qtgui_1_1time__sink__c.html" title="A graphical sink to display multiple signals in time. ">gr::qtgui::time_sink_c</a> and <a class="el" href="classgr_1_1qtgui_1_1time__sink__f.html" title="A graphical sink to display multiple signals in time. ">gr::qtgui::time_sink_f</a>): x-axis is time, y-axis is amplitude. </li>
<li>Frequency Domain or PSD (<a class="el" href="classgr_1_1qtgui_1_1freq__sink__c.html" title="A graphical sink to display multiple signals in frequency. ">gr::qtgui::freq_sink_c</a> and <a class="el" href="classgr_1_1qtgui_1_1freq__sink__f.html" title="A graphical sink to display multiple signals in frequency. ">gr::qtgui::freq_sink_f</a>): x-axis is frequency, y-axis is magnitude in dB. </li>
<li>Waterfall or spectrogram (<a class="el" href="classgr_1_1qtgui_1_1waterfall__sink__c.html" title="A graphical sink to display multiple signals on a waterfall (spectrogram) plot. ">gr::qtgui::waterfall_sink_c</a> and <a class="el" href="classgr_1_1qtgui_1_1waterfall__sink__f.html" title="A graphical sink to display multiple signals on a waterfall (spectrogram) plot. ">gr::qtgui::waterfall_sink_f</a>): x-axis is frequency, y-axis is time,z-axis is intensity related to magnitude in dB. </li>
<li>Constellation (<a class="el" href="classgr_1_1qtgui_1_1const__sink__c.html" title="A graphical sink to display the IQ constellation of multiple signals. ">gr::qtgui::const_sink_c</a>): polar plot of real vs. imaginary. </li>
<li>Time Raster (<a class="el" href="classgr_1_1qtgui_1_1time__raster__sink__f.html" title="A graphical sink to display multiple signals on a time_raster plot. ">gr::qtgui::time_raster_sink_f</a> and <a class="el" href="classgr_1_1qtgui_1_1time__raster__sink__b.html" title="A graphical sink to display multiple signals on a time_raster plot. ">gr::qtgui::time_raster_sink_b</a>): time vs. time with the z-axis being intensity basedon value of the sample. </li>
<li>Histogram (<a class="el" href="classgr_1_1qtgui_1_1histogram__sink__f.html" title="A graphical sink to display a histogram. ">gr::qtgui::histogram_sink_f</a>): Displays a histogram of the data stream. </li>
<li>Combined Sink (<a class="el" href="classgr_1_1qtgui_1_1sink__c.html" title="A graphical sink to display freq, spec, time, and const plots. ">gr::qtgui::sink_c</a> and <a class="el" href="classgr_1_1qtgui_1_1sink__f.html" title="A graphical sink to display freq, spec, and time. ">gr::qtgui::sink_f</a>): combines time, frequency, waterfall, and constellation plots into one widget.</li>
</ul>
<p>The time domain, frequency domain, and waterfall have both a complex and a floating point block. The constellation plot only makes sense with complex inputs. The time raster plots accept bits and floats.</p>
<p>Because the time raster plots are designed to show structure over time in a signal, frame, packet, etc., they never drop samples. This is a fairly taxing job and performance can be an issue. Since it is expected that this block will work on a frame or packet structure, we tend to be at the lowest possible rate at this point, so that will help. Expect performance issues at high data rates.</p>
<p>Note: There seem to be extra performance issues with the raster plotters in QWT version 5 that were fixed with QWT version 6. As such, the time raster plots have incredibly poor performance with QWT5 to the point of almost being unusable. In the future, we may restrict compilation and installation of these plots only if QWT6 or higher is discovered. For now, just be aware of this limitation.</p>
<h1><a class="anchor" id="qtgui_menu"></a>
Drop-Down Menu and Interacting with Plots</h1>
<p>All QTGUI sinks have interactive capabilities.</p>
<ul>
<li>Zooming is done simply by clicking the left mouse button and dragging a rectangle around the area to zoom. </li>
<li>Zooming can be done in multiple steps. </li>
<li>A right mouse click will zoom out one step. </li>
<li>Ctrl+Right mouse click will zoom all the way out. </li>
<li>Ctrl+Middle mouse click and hold can drag the canvas around. </li>
<li>Mouse wheel up/down will zoom out/in on y axis (both axes in constellation plot). </li>
<li>Middle mouse button brings up a context menu.</li>
</ul>
<p>Each type of graph has a different set of menu items in the context menu. Most have some way to change the appearance of the lines or surfaces, such as changing the line width color, marker, and transparency. Other common features can set the sampling rate, turn a grid on and off, pause and unpause (stop/start) the display update, and save the current figure. Specific features are things like setting the number of points to display, setting the FFT size, FFT window, and any FFT averaging.</p>
<h2><a class="anchor" id="qtgui_menu_trigger"></a>
Triggering Menu for Time Plots</h2>
<p>The time plots have triggering capabilities. Triggering can happen when the signal of a specific channel crosses (positive or negative slope) a certain level threshold. Or triggering can be done off a specific stream tag such that whenever a tag of a given key is found, the scope will trigger.</p>
<p>In the signal level mode, the trigger can be either 'auto' or 'normal' where the latter will only trigger when the event is seen. The 'auto' mode will trigger on the event or every so often even if no trigger is found. The 'free' mode ignores triggering and continuously plots.</p>
<p>By default, the triggers plot the triggering event at the x=0 (i.e., the left-most point in the plot). A delay can be set to delay the signal along the x-axis to observe any signal before the triggering event. The delay feature works the same for both level and tag triggers. The delay is set according to time in seconds, not samples. So the delay can be calculated as the number of samples divided by the sample rate given to the block.</p>
<p>All trigger settings (mode, slope, level, delay, channel, and tag key) are settable in the GRC properties boxes to easily set up a repeatable environment.</p>
<p>A note on the trigger delay setting. This value is limited by the buffer size and/or the number of points being display. It is capped by the minimum of these two values. The buffer size issue is generally only a problem when plotting a large number of samples. However, if the delay is set large to begin with (in the GRC properties box or before top_block.start() is called), then the buffers are resized accordingly offering more freedom. This should be a problem in a limited number of scenarios, but a log INFO level message is produced when asking for the delay outside of the available range.</p>
<h1><a class="anchor" id="qtgui_dependencies"></a>
Dependencies</h1>
<p>The QT GUI blocks require the following dependencies.</p>
<ul>
<li>QtCore (version &gt;= 4.4) </li>
<li>QtGui (version &gt;= 4.4) </li>
<li>QtOpenGL (version &gt;= 4.4) </li>
<li>PyQt4 for Qt4 (version &gt;= 4.4) </li>
<li>Qwt (version &gt;= 5.2)</li>
</ul>
<h1><a class="anchor" id="qtgui_usage"></a>
Usage</h1>
<p>To use the QTGUI interface, a bit of boiler-plate lines must be included. First, the sink is defined, then it must be exposed from C++ into Python using the "sip.wrapinstance" command, and finally, the "show" method is run on the new Python object. This sets up the QT environment to show the widget, but the qApplication must also be launched.</p>
<p>In the "main" function of the code, the qApp is retrieved. Then, after the GNU Radio top block is started (remember that start() is a non-blocking call to launch the main thread of the flowgraph), the qapp's "exec_()" function is called. This function is a blocking call while the GUI is alive.</p>
<div class="fragment"><div class="line">from PyQt4 <span class="keyword">import</span> Qt</div><div class="line">from <a class="code" href="namespacegnuradio.html">gnuradio</a> <span class="keyword">import</span> qtgui</div><div class="line"><span class="keyword">import</span> sys, sip</div><div class="line"></div><div class="line"><span class="keyword">class </span>grclass(gr.top_block):</div><div class="line">    ....</div><div class="line"></div><div class="line">    self.snk = qtgui.sink_c(1024,           #fftsize</div><div class="line">                            samp_rate,      #bw</div><div class="line">                            &quot;QT GUI Plot&quot;)  #name</div><div class="line"></div><div class="line">    self.snk_win = sip.wrapinstance(self.snk.pyqwidget(), Qt.QWidget)</div><div class="line">    self.snk_win.show()</div><div class="line"></div><div class="line">def main():</div><div class="line">    qapp = Qt.QApplication(sys.argv)</div><div class="line">    tb = grclass()</div><div class="line">    tb.start()</div><div class="line">    qapp.exec_()</div><div class="line">    tb.stop()</div></div><!-- fragment --><p>There are graphical controls in all but the combined plotting tools. In the margins of the GUIs (that is, not on the canvas showing the signal itself), right-clicking the mouse will pull up a drop-down menu that will allow you to change difference parameters of the plots. These include things like the look of the lines (width, color, style, markers, etc.), the ability to start and stop the display, the ability to save to a file, and other plot-specific controls (FFT size for the frequency and waterfall plots, etc.).</p>
<h1><a class="anchor" id="qtgui_messages"></a>
Message Input Support</h1>
<p>All QTGUI sinks can accept and plot messages over their "in" message port. The message types must either be uniform vectors or PDUs. The data type held within the uniform vector or PDU must match the data type of the block itself. For example, a qtgui.time_sink_c will only handle vectors that pass the <a class="el" href="namespacepmt.html#aeb135345903361a969d0e90ddb191272">pmt::is_c32vector</a> test while a qtgui.time_sink_f will only handle vectors that pass the <a class="el" href="namespacepmt.html#afbdce2e3a9a172fdbdcf9da08cce862a">pmt::is_f32vector</a> test.</p>
<p>The sinks must only be used with one type of input model: streaming or messages. You cannot use them both together or unknown behavior will occur.</p>
<p>In the GNU Radio Companion, the QTGUI sink blocks can be set to message mode by changing the Type field. Most of the QTGUI sinks support multiple data types, even for messages, but GRC only displays the message type as the single gray color. Within the block's property box, you can set the type to handle the correct message data type (e.g., 'Complex Message' or 'Float Message'). When using a message type interface, GRC will hide certain parameters that are not usable or settable anymore. For example, when plotting a message in the time sink, the number of points shown in the time sink is determined by the length of the vector in the message. Presetting this in the GUI would have no effect. This behavior in GRC is for convenience and to try and reduce confusion about properties and settings in the message mode. However, all of the API hooks are still there, so it is possible to set all of this programmatically. The results would be harmless, however.</p>
<p>Here is an example of setting up and using a message passing complex time sink block:</p>
<div class="fragment"><div class="line">from <a class="code" href="namespacegnuradio.html">gnuradio</a> <span class="keyword">import</span> gr, qtgui</div><div class="line"></div><div class="line">tsnk = qtgui.time_sink_c(1024, samp_rate, <span class="stringliteral">&quot;&quot;</span>, 0)</div><div class="line">tsnk.set_update_time(0.05)</div><div class="line">tsnk.set_y_axis(-1.25, 1.25)</div><div class="line">tsnk.set_y_label(<span class="stringliteral">&quot;Amp (V)&quot;</span>, <span class="stringliteral">&quot;&quot;</span>)</div><div class="line">tsnk.enable_autoscale(False)</div><div class="line">tsnk.enable_grid(False)</div><div class="line">tsnk.enable_control_panel(False)</div><div class="line"></div><div class="line">tb = gr.top_block()</div><div class="line">msg_block = ? # some PDU/message generating block</div><div class="line">tb.msg_connect((msg_block, <span class="stringliteral">&#39;msg&#39;</span>), (tsnk, <span class="stringliteral">&#39;in&#39;</span>))</div></div><!-- fragment --><h1><a class="anchor" id="qtgui_widgets"></a>
QTGUI Widgets</h1>
<p>The QTGUI component also includes a number of widgets that can be used to perform live updates of variables through standard QT input widgets. Most of the widgets are implemented directly in Python through PyQT. However, GNU Radio is introducing more widgets, written and therefore available in C++ that also produce messages. The Python-based widgets only act as variables and so as they are changed, any block using those widgets to set parameters has the callback (i.e., set_value()) function's called.</p>
<h2><a class="anchor" id="qtgui_widgets_python"></a>
Python widgets:</h2>
<ul>
<li>Range: creates a slider and/or combo box to change to set/change the value of a parameter. This widget can set either float or int values. </li>
<li>Entry: An edit box that allows a user to directly set a new value for the parameter. </li>
<li>Chooser: Creates a drop-down menu of pre-set values. </li>
<li>Check Box: Creates a check box. The user sets what the value of the check means when enabled or disabled. </li>
<li>Push Button: Adds a button that changes state when pushed versus released (no sticky). The user sets up what the value is when pressed versus when released. </li>
<li>Label: Adds a Label widget to annotate the GUI. Generally not used as a variable. </li>
<li>Tab Widget: Adds a tab widget that can house other GUI widgets to format the interface. Use the GUI hint of the other QT widgets and instruments to specify if and where they exist in the tab widget using the format "tag widget name@index: row, col, row span, col
span". Simply using "tab widget name@index" will put that widget into the specific index (starting at 0) of the tab widget while adding the "row, col, row span, col span" will allow the user to place them in the tab grid.</li>
</ul>
<h2><a class="anchor" id="qtgui_widgets_cpp"></a>
C++ and Message-Passing Widgets</h2>
<ul>
<li><a class="el" href="classgr_1_1qtgui_1_1edit__box__msg.html">Message Edit Box</a>: A QT edit box that emits a message when editing is done (e.g., user presses enter, tabs out of the widget, or mouse-clicks out of the widget). The message type is settable as are the contents. Messages can be sent as key:value pairs when Pair Mode is enabled. When Static Mode is enabled, the data type and the pair key (if in Pair Mode) are set at the start and cannot be changed at runtime.</li>
</ul>
<h1><a class="anchor" id="qtgui_configuration"></a>
Configuration</h1>
<p>There is currently a single configuration option in the preferences files to set the rendering engine of the QTGUI sinks. Located in etc/gnuradio/conf.d/gr-qtgui.conf:</p>
<pre class="fragment">[qtgui]
style = raster
</pre><p>The available styles are:</p>
<ul>
<li>opengl: the fastest but not likely to always work </li>
<li>raster: fast and stable; terrible X forwarding performance </li>
<li>native: most compute intensive; very good over X</li>
</ul>
<p>We default this setting to raster for the mix of performance and usability. When using QTGUI sinks through an X-forwarding session over SSH, switch to using 'native' for a significant speed boost on the remote end.</p>
<p>We can also set a QT Style Sheet (QSS) file to adjust the look of our plotting tools. Set the 'qss' option of the 'qtgui' section in our configuration file to a QSS file. An example QSS file is distributed with the QTGUI examples found in share/gnuradio/examples/qt-gui/dark.qss. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
