<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>GNU Radio Manual and C++ API Reference: Stream Tags</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gnuradio_logo_icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GNU Radio Manual and C++ API Reference
   &#160;<span id="projectnumber">3.7.13.4</span>
   </div>
   <div id="projectbrief">The Free &amp; Open Software Radio Ecosystem</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_stream_tags.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Stream Tags </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="stream_tags_introduction"></a>
Introduction</h1>
<p>GNU Radio was originally a streaming system with no other mechanism to pass data between blocks. Streams of data are a model that work well for samples, bits, etc., but can lack for control and meta data.</p>
<p>Part of this is solved using the existing message passing interface, which allows blocks to subscribe to messages published by any other block in the flowgraph (see <a class="el" href="page_msg_passing.html">Message Passing</a>). The main drawback to the message passing system is that is works asynchronously, meaning that there is no guarantee when a message may arrive relative to the data stream.</p>
<p>Stream tags are an isosynchronous data stream that runs parallel to the main data stream. A stream <em>tag</em> is generated by a block's work function and from there on flows downstream alongside a particular sample, until it reaches a sink or is forced to stop propagating by another block.</p>
<p>Stream tags are defined for a specific item in the data stream and are formed as a key:value pair. The <em>key</em> identifies what the <em>value</em> represents while the value holds the data that the tag contains. Both <em>key</em> and <em>value</em> are PMTs (<a class="el" href="page_pmt.html">Polymorphic Types</a>) where the <em>key</em> is a PMT symbol while the <em>value</em> is any type of PMT and can therefore handle any data we wish to pass. An additional part of the tag is the <em>srcid</em>, which is a PMT symbol and is used to identify the block that created the tag (which is usually the block's alias).</p>
<h1><a class="anchor" id="stream_tags_block_api_extensions"></a>
API Extensions to the gr::block</h1>
<p>To enable the stream tags, we have extended the API of <a class="el" href="classgr_1_1block.html" title="The abstract base class for all &#39;terminal&#39; processing blocks.A signal processing flow is constructed ...">gr::block</a> to understand <em>absolute</em> item numbers. In the data stream model, each block's work function is given a buffer in the data stream that is referenced from 0 to N-1. This is a <em>relative</em> offset into the data stream. The absolute reference starts from the beginning of the flowgraph and continues to count up with every item. Each input stream is associated with a concept of the 'number of items read' and each output stream has a 'number of items written'. These are retrieved during runtime using the two API calls:</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> nitems_read(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> which_input);</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> nitems_written(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> which_output);</div></div><!-- fragment --><p>Each tag is associated with some item in this absolute time scale that is calculated using these functions.</p>
<p>Like the rest of the data stream, the number of items read/written are only updated once during the call to work. So in a work function, nitems_read/written will refer to the state of the data stream at the start of the work function. We must therefore add to this value the current relative offset in the data stream. So if we are iterating <em>i</em> over all output items, we would write the stream tag to output ports at <em>nitems_written(0)+i</em> for the 0th output port.</p>
<h1><a class="anchor" id="stream_tags_api"></a>
Stream Tags API</h1>
<p>The stream tags API is split into two parts: adding tags to a stream, and getting tags from a stream. Note that the functions described below are only meant to be accessed within a call to general_work/work. While they can be called at other points in time by a block, the behavior outside of work is undefined without exact knowledge of the item counts in the buffers.</p>
<h2><a class="anchor" id="stream_tags_add_item_tag"></a>
Adding a Tag to a Stream</h2>
<p>We add a tag to a particular output stream of the block using:</p>
<ul>
<li><a class="el" href="classgr_1_1block.html#a8b7cc51b9d289124d6843bb392f564fc" title="Adds a new tag onto the given output buffer. ">gr::block::add_item_tag</a>: Adds an item tag to a particular output port using a <a class="el" href="structgr_1_1tag__t.html">gr::tag_t</a> data type or by specifying the tag values.</li>
</ul>
<p>We can output them to multiple output streams if we want, but to do so means calling this function once for each port. This function can be provided with a <a class="el" href="structgr_1_1tag__t.html">gr::tag_t</a> data type, or each value of the tag can be explicitly given.</p>
<p>Again, a tag is defined as:</p>
<ul>
<li>offset: The offset, in absolute item time, of the tag in the data stream. </li>
<li>key: the PMT symbol identifying the type of tag. </li>
<li>value: the PMT holding the data of the tag. </li>
<li>srcid: (optional) the PMT symbol identifying the block which created the tag.</li>
</ul>
<p>We can create a <a class="el" href="structgr_1_1tag__t.html">gr::tag_t</a> structure to hold all of the above information of a tag, which is probably the easiest/best way to do it. The <a class="el" href="structgr_1_1tag__t.html">gr::tag_t</a> struct is defined as having the same members as in the above list. To add a <a class="el" href="structgr_1_1tag__t.html">gr::tag_t</a> tag to a stream, use the function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> add_item_tag(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> which_output, <span class="keyword">const</span> tag_t &amp;tag);</div></div><!-- fragment --><p>The secondary API allows us to create a tag by explicitly listing all of the tag information in the function call:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> add_item_tag(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> which_output,</div><div class="line">                  uint64_t abs_offset,</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> &amp;key,</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> &amp;value,</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> &amp;srcid=<a class="code" href="pmt_8h.html#a14555f1d3794ee65b982b9fb74adca9e">pmt::PMT_F</a>);</div></div><!-- fragment --><h2><a class="anchor" id="stream_tags_get_item_tags"></a>
Getting tags from a Stream</h2>
<p>To get tags from a particular input stream, we have two functions we can use:</p>
<ul>
<li><a class="el" href="classgr_1_1block.html#aa0272555827fe26a1878e53ce4be092c" title="Given a [start,end), returns a vector of all tags in the range. ">gr::block::get_tags_in_range</a>: Gets all tags from a particular input port between a certain range of items (in absolute item time).</li>
</ul>
<ul>
<li><a class="el" href="classgr_1_1block.html#abf2cc497d68c4650be55765d0fe12291" title="Gets all tags within the relative window of the current call to work. ">gr::block::get_tags_in_window</a>: Gets all tags from a particular input port between a certain range of items (in relative item time within the work function).</li>
</ul>
<p>The difference between these functions is working in absolute item time versus relative item time. Both of these pass back vectors of <a class="el" href="structgr_1_1tag__t.html">gr::tag_t</a>, and they both allow specifying a particular key (as a PMT symbol) to filter against (or the fifth argument can be left out to search for all keys). Filtering for a certain key reduces the effort inside the work function for getting the right tag's data.</p>
<p>For example, this call just returns any tags between the given range of items:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> get_tags_in_range(std::vector&lt;tag_t&gt; &amp;<a class="code" href="structv.html">v</a>,</div><div class="line">                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> which_input,</div><div class="line">                       uint64_t abs_start,</div><div class="line">                       uint64_t abs_end);</div></div><!-- fragment --><p>Adding a fifth argument to this function allows us to filter on the key <em>key</em>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> get_tags_in_range(std::vector&lt;tag_t&gt; &amp;<a class="code" href="structv.html">v</a>,</div><div class="line">                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> which_input,</div><div class="line">                       uint64_t abs_start,</div><div class="line">                       uint64_t abs_end,</div><div class="line">                       <span class="keyword">const</span> <a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> &amp;key);</div></div><!-- fragment --><h1><a class="anchor" id="stream_tags_propagation"></a>
Tag Propagation</h1>
<p>Tags are propagated downstream from block to block like the normal data streams. How tags are actually moved depends on a specific propagation policy. We defined three types of policies:</p>
<ul>
<li>All-to-All: all tags from any input port are replicated to all output ports </li>
<li>One-to-One: tags from input port <em>i</em> are only copied to output port <em>i</em> (depends on num inputs = num outputs). </li>
<li>Dont: Does not propagate tags. Tags are either stopped here or the work function recreates them in some manner.</li>
</ul>
<p>The default behavior of a block is the 'All-to-All' method of propagation.</p>
<p>To set a different propagation policy, use the function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_tag_propagation_policy(<a class="code" href="namespacegr.html#a103e36c388d20ee8c7312cb6d52bdf81">tag_propagation_policy_t</a> p);</div></div><!-- fragment --><p>See the <a class="el" href="classgr_1_1block.html#abc40fd4d514724a5446a2b34b2352b4e" title="enum to represent different tag propagation policies. ">gr::block::tag_propagation_policy_t</a> documentation for details on this enum type.</p>
<h2><a class="anchor" id="stream_tags_rate_changes"></a>
Tag Propagation through Rate Changes</h2>
<p>When a tag is propagated through a block that has a rate change, the item's offset in the data stream will change. The scheduler uses the block's <a class="el" href="classgr_1_1block.html#aa14aceb3623b74b66d235fbb237cec88" title="return the approximate output rate / input rate ">gr::block::relative_rate</a> concept to perform the update on the tag's offset value. The relative rate of a block determines the relationship between the input rate and output rate. Decimators that decimate by a factor of <em>D</em> have a relative rate of <em>1/D</em>.</p>
<p>Synchronous blocks (<a class="el" href="classgr_1_1sync__block.html" title="synchronous 1:1 input to output with historyOverride work to provide the signal processing implementa...">gr::sync_block</a>), decimators (<a class="el" href="classgr_1_1sync__decimator.html" title="synchronous N:1 input to output with historyOverride work to provide the signal processing implementa...">gr::sync_decimator</a>), and interpolators (<a class="el" href="classgr_1_1sync__interpolator.html" title="synchronous 1:N input to output with historyOverride work to provide the signal processing implementa...">gr::sync_interpolator</a>) all have pre-defined and well-understood relative rates. A standard <a class="el" href="classgr_1_1block.html" title="The abstract base class for all &#39;terminal&#39; processing blocks.A signal processing flow is constructed ...">gr::block</a> has a default relative rate of 1.0, but this must be set if it does not work this way. Often, we use a <a class="el" href="classgr_1_1block.html" title="The abstract base class for all &#39;terminal&#39; processing blocks.A signal processing flow is constructed ...">gr::block</a> because we have no pre-conceived notion of the number of input to output items. If it is important to pass tags through these blocks that respect the change in item value, we would have to use the TPP_DONT tag propagation policy and handle the propagation internally.</p>
<p>In no case is the value of the tag modified when propagating through a block. This becomes relevant when using <a class="el" href="page_tagged_stream_blocks.html">Tagged Stream Blocks</a>.</p>
<h1><a class="anchor" id="stream_tags_issues"></a>
Notes on How to Use Tags</h1>
<p>Tags can be very useful to an application, and their use is spreading. USRP sources generate tag information on the time, sample rate, and frequency of the board if anything changes. We have a meta data file source/sink (see <a class="el" href="page_metadata.html">Metadata Information</a>) that use tags to store information about the data stream. But there are things to think about when using tags in a block.</p>
<p>First, when tags are not being used, there is almost no effect on the scheduler. However, when we use tags, we add overhead by getting and extracting tags from a data stream. We also use overhead in propagating the tags. For each tag, each block must copy a vector of tags from the output port(s) of one block to the input port(s) of the next block(s). These copy operations can add up.</p>
<p>The key is to minimize the use of tags. Use them when and only when necessary and try to provide some control over how tags are generated to control their frequency. A good example is the USRP source, which generates a time tag. If it generated a tag with every sample, we would have thousands of tags per second, which would add a significant amount of overhead. This is because if we started at time <em>t0</em> at sample rate <em>sr</em>, then after <em>N</em> samples, we know that we are now at time <em>t0 + N/sr</em>. So continuously producing new tags adds no information.</p>
<p>The main issue we need to deal with in the above situation is when there is a discontinuity in the packets received from the USRP. Since we have no way of knowing in the flowgraph how many samples were potentially lost, we have lost track of the timing information. The USRP driver recognizes when packets have been dropped and uses this to queue another tag, which allows us to resync. Likewise, any point the sample rate or frequency changes, a new tag is issued. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
