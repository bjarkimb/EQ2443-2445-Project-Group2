<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>GNU Radio Manual and C++ API Reference: Polyphase Filterbanks</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gnuradio_logo_icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GNU Radio Manual and C++ API Reference
   &#160;<span id="projectnumber">3.7.13.4</span>
   </div>
   <div id="projectbrief">The Free &amp; Open Software Radio Ecosystem</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_pfb.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Polyphase Filterbanks </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="pfb_introduction"></a>
Introduction</h1>
<p>Polyphase filterbanks (PFB) are a very powerful set of filtering tools that can efficiently perform many multi-rate signal processing tasks. GNU Radio has a set of polyphase filterbank blocks to be used in all sorts of applications.</p>
<h1><a class="anchor" id="pfb_Usage"></a>
pfb_Usage</h1>
<p>See the documentation for the individual blocks for details about what they can do and how they should be used. Furthermore, there are examples for these blocks in <b>gr-filter/examples</b>.</p>
<p>The main issue when using the PFB blocks is defining the prototype filter, which is passed to all of the blocks as a vector of <code>taps</code>. The taps from the prototype filter which get partitioned among the <code>N</code> channels of the channelizer.</p>
<p>An example of creating a set of filter taps for a PFB channelizer is found on line 49 of <b>gr-filter/examples/channelizer.py</b> and reproduced below. Notice that the sample rate is the sample rate at the input to the channelizer while the bandwidth and transition width are defined for the channel bandwidths. This makes a fairly long filter that is then split up between the <code>N</code> channels of the PFB.</p>
<div class="fragment"><div class="line"><span class="keyword">self</span>._fs = 9000          # input sample rate</div><div class="line"><span class="keyword">self</span>._M = 9              # Number of channels to channelize</div><div class="line"></div><div class="line"><span class="keyword">self</span>._taps = filter.firdes.low_pass_2(1, <span class="keyword">self</span>._fs, 475.50, 50,</div><div class="line">                                      attenuation_dB=100,</div><div class="line">                                      window=filter.firdes.WIN_BLACKMAN_hARRIS)</div></div><!-- fragment --><p>In this example, the signal into the channelizer is sampled at 9 ksps (complex, so 9 kHz of bandwidth). The filter uses 9 channels, so each output channel will have a bandwidth and sample rate of 1 kHz. We want to pass most of the channel, so we define the channel bandwidth to be a low pass filter with a bandwidth of 475.5 Hz and a transition bandwidth of 50 Hz, but we have defined this using a sample rate of the original 9 kHz. The prototype filter has 819 taps to be divided up between the 9 channels, so each channel uses 91 taps. This is probably over-kill for a channelizer, and we could reduce the amount of taps per channel to a couple of dozen with no ill effects.</p>
<p>The basic rule when defining a set of taps for a PFB block is to think about the filter running at the highest rate it will see while the bandwidth is defined for the size of the channels. In the channelizer case, the highest rate is defined as the rate of the incoming signal, but in other PFB blocks, this is not so obvious.</p>
<p>Two very useful blocks to use are the arbitrary resampler and the clock synchronizer (for PAM signals). These PFBs are defined with a set number of filters based on the fidelity required from them, not the rate changes. By default, the <code>filter_size</code> is set to 32 for these blocks, which is a reasonable default for most tasks. Because the PFB uses this number of filters in the filterbank, the maximum rate of the bank is defined from this (see the theory of a polyphase interpolator for a justification of this). So the prototype filter is defined to use a sample rate of <code>filter_size</code> times the signal's sampling rate.</p>
<p>A helpful wrapper for the arbitrary resampler is found in <b>gr-filter/python/pfb.py</b>, which is exposed in Python as <b>filter.pfb.arb_resampler_ccf</b> and <b>filter.pfb.arb_resampler_fff</b>. This block is set up so that the user only needs to pass it the real number <code>rate</code> as the resampling rate. With just this information, this hierarchical block automatically creates a filter that fully passes the signal bandwidth being resampled but does not pass any out-of-band noise. See the code for this block for details of how the filter is constructed.</p>
<p>Of course, a user can create his or her own taps and use them in the arbitrary resampler for more specific requirements. Some of the UHD examples (<b>gr-uhd/examples</b>) use this ability to create a received matched filter or channel filter that also resamples the signal.</p>
<h1><a class="anchor" id="pfb_examples"></a>
Examples</h1>
<p>The following is an example of the using the channelizer. It creates the appropriate filter to channelizer 9 channels out of an original signal that is 9000 Hz wide, so each output channel is now 1000 Hz. The code then plots the PSD of the original signal to see the signals in the origina spectrum and then makes 9 plots for each of the channels.</p>
<p>NOTE: you need the Scipy and Matplotlib Python modules installed to run this example.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">#!/usr/bin/env python</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">#</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment"># Copyright 2009,2012,2013 Free Software Foundation, Inc.</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">#</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment"># This file is part of GNU Radio</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">#</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment"># GNU Radio is free software; you can redistribute it and/or modify</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment"># it under the terms of the GNU General Public License as published by</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment"># the Free Software Foundation; either version 3, or (at your option)</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment"># any later version.</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">#</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment"># GNU Radio is distributed in the hope that it will be useful,</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment"># GNU General Public License for more details.</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment">#</span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment"># You should have received a copy of the GNU General Public License</span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment"># along with GNU Radio; see the file COPYING.  If not, write to</span></div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment"># the Free Software Foundation, Inc., 51 Franklin Street,</span></div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment"># Boston, MA 02110-1301, USA.</span></div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment">#</span></div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="keyword">from</span> gnuradio <span class="keyword">import</span> gr</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="keyword">from</span> gnuradio <span class="keyword">import</span> blocks</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="keyword">from</span> gnuradio <span class="keyword">import</span> filter</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="keyword">import</span> sys, time</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="keywordflow">try</span>:</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    <span class="keyword">from</span> gnuradio <span class="keyword">import</span> analog</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="keywordflow">except</span> ImportError:</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    sys.stderr.write(<span class="stringliteral">&quot;Error: Program requires gr-analog.\n&quot;</span>)</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    sys.exit(1)</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="keywordflow">try</span>:</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <span class="keyword">import</span> scipy</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <span class="keyword">from</span> scipy <span class="keyword">import</span> fftpack</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="keywordflow">except</span> ImportError:</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    sys.stderr.write(<span class="stringliteral">&quot;Error: Program requires scipy (see: www.scipy.org).\n&quot;</span>)</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    sys.exit(1)</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="keywordflow">try</span>:</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    <span class="keyword">import</span> pylab</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    <span class="keyword">from</span> pylab <span class="keyword">import</span> mlab</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="keywordflow">except</span> ImportError:</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    sys.stderr.write(<span class="stringliteral">&quot;Error: Program requires matplotlib (see: matplotlib.sourceforge.net).\n&quot;</span>)</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    sys.exit(1)</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="keyword">class </span>pfb_top_block(<a class="code" href="classgr_1_1top__block.html">gr.top_block</a>):</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <span class="keyword">def </span>__init__(self):</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        gr.top_block.__init__(self)</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        self._N = 2000000        <span class="comment"># number of samples to use</span></div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        self._fs = 1000          <span class="comment"># initial sampling rate</span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        self._M = M = 9          <span class="comment"># Number of channels to channelize</span></div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        self._ifs = M*self._fs   <span class="comment"># initial sampling rate</span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        <span class="comment"># Create a set of taps for the PFB channelizer</span></div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        self._taps = filter.firdes.low_pass_2(1, self._ifs, 475.50, 50,</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;                                              attenuation_dB=100,</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;                                              window=filter.firdes.WIN_BLACKMAN_hARRIS)</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        <span class="comment"># Calculate the number of taps per channel for our own information</span></div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        tpc = scipy.ceil(float(len(self._taps)) /  float(self._M))</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        <span class="keywordflow">print</span> <span class="stringliteral">&quot;Number of taps:     &quot;</span>, len(self._taps)</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        <span class="keywordflow">print</span> <span class="stringliteral">&quot;Number of channels: &quot;</span>, self._M</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        <span class="keywordflow">print</span> <span class="stringliteral">&quot;Taps per channel:   &quot;</span>, tpc</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;        <span class="comment"># Create a set of signals at different frequencies</span></div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;        <span class="comment">#   freqs lists the frequencies of the signals that get stored</span></div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        <span class="comment">#   in the list &quot;signals&quot;, which then get summed together</span></div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        self.signals = list()</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;        self.add = blocks.add_cc()</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        freqs = [-70, -50, -30, -10, 10, 20, 40, 60, 80]</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> xrange(len(freqs)):</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;            f = freqs[i] + (M/2-M+i+1)*self._fs</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;            self.signals.append(analog.sig_source_c(self._ifs, analog.GR_SIN_WAVE, f, 1))</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;            self.connect(self.signals[i], (self.add,i))</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        self.head = blocks.head(gr.sizeof_gr_complex, self._N)</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        <span class="comment"># Construct the channelizer filter</span></div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        self.pfb = filter.pfb.channelizer_ccf(self._M, self._taps, 1)</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;        <span class="comment"># Construct a vector sink for the input signal to the channelizer</span></div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        self.snk_i = blocks.vector_sink_c()</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        <span class="comment"># Connect the blocks</span></div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        self.connect(self.add, self.head, self.pfb)</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        self.connect(self.add, self.snk_i)</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        <span class="comment"># Use this to play with the channel mapping</span></div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;        <span class="comment">#self.pfb.set_channel_map([5,6,7,8,0,1,2,3,4])</span></div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;        <span class="comment"># Create a vector sink for each of M output channels of the filter and connect it</span></div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;        self.snks = list()</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> xrange(self._M):</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;            self.snks.append(blocks.vector_sink_c())</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;            self.connect((self.pfb, i), self.snks[i])</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;<span class="keyword">def </span>main():</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    tstart = time.time()</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    tb = pfb_top_block()</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    tb.run()</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    tend = time.time()</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <span class="keywordflow">print</span> <span class="stringliteral">&quot;Run time: %f&quot;</span> % (tend - tstart)</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    <span class="keywordflow">if</span> 1:</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        fig_in = pylab.figure(1, figsize=(16,9), facecolor=<span class="stringliteral">&quot;w&quot;</span>)</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        fig1 = pylab.figure(2, figsize=(16,9), facecolor=<span class="stringliteral">&quot;w&quot;</span>)</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        fig2 = pylab.figure(3, figsize=(16,9), facecolor=<span class="stringliteral">&quot;w&quot;</span>)</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        Ns = 1000</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        Ne = 10000</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;        fftlen = 8192</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        winfunc = scipy.blackman</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;        fs = tb._ifs</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        <span class="comment"># Plot the input signal on its own figure</span></div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        d = tb.snk_i.data()[Ns:Ne]</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        spin_f = fig_in.add_subplot(2, 1, 1)</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        X,freq = mlab.psd(d, NFFT=fftlen, noverlap=fftlen/4, Fs=fs,</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;                          window = <span class="keyword">lambda</span> d: d*winfunc(fftlen),</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;                          scale_by_freq=<span class="keyword">True</span>)</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        X_in = 10.0*scipy.log10(abs(X))</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;        f_in = scipy.arange(-fs/2.0, fs/2.0, fs/float(X_in.size))</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;        pin_f = spin_f.plot(f_in, X_in, <span class="stringliteral">&quot;b&quot;</span>)</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        spin_f.set_xlim([<a class="code" href="namespacegr_1_1trellis.html#aa1d6afaca822df7b2a521046596d3230">min</a>(f_in), max(f_in)+1])</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        spin_f.set_ylim([-200.0, 50.0])</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;        spin_f.set_title(<span class="stringliteral">&quot;Input Signal&quot;</span>, weight=<span class="stringliteral">&quot;bold&quot;</span>)</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;        spin_f.set_xlabel(<span class="stringliteral">&quot;Frequency (Hz)&quot;</span>)</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        spin_f.set_ylabel(<span class="stringliteral">&quot;Power (dBW)&quot;</span>)</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;        Ts = 1.0/fs</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;        Tmax = len(d)*Ts</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        t_in = scipy.arange(0, Tmax, Ts)</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;        x_in = scipy.array(d)</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        spin_t = fig_in.add_subplot(2, 1, 2)</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        pin_t = spin_t.plot(t_in, x_in.real, <span class="stringliteral">&quot;b&quot;</span>)</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;        pin_t = spin_t.plot(t_in, x_in.imag, <span class="stringliteral">&quot;r&quot;)</span></div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;<span class="stringliteral">        spin_t.set_xlabel(&quot;Time (s)&quot;</span>)</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;        spin_t.set_ylabel(<span class="stringliteral">&quot;Amplitude&quot;</span>)</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        Ncols = int(scipy.floor(scipy.sqrt(tb._M)))</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;        Nrows = int(scipy.floor(tb._M / Ncols))</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;        if(tb._M % Ncols != 0):</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;            Nrows += 1</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        <span class="comment"># Plot each of the channels outputs. Frequencies on Figure 2 and</span></div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;        <span class="comment"># time signals on Figure 3</span></div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;        fs_o = tb._fs</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        Ts_o = 1.0/fs_o</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;        Tmax_o = len(d)*Ts_o</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> xrange(len(tb.snks)):</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;            <span class="comment"># remove issues with the transients at the beginning</span></div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;            <span class="comment"># also remove some corruption at the end of the stream</span></div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;            <span class="comment">#    this is a bug, probably due to the corner cases</span></div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;            d = tb.snks[i].data()[Ns:Ne]</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;            sp1_f = fig1.add_subplot(Nrows, Ncols, 1+i)</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;            X,freq = mlab.psd(d, NFFT=fftlen, noverlap=fftlen/4, Fs=fs_o,</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;                              window = <span class="keyword">lambda</span> d: d*winfunc(fftlen),</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;                              scale_by_freq=<span class="keyword">True</span>)</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;            X_o = 10.0*scipy.log10(abs(X))</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;            f_o = scipy.arange(-fs_o/2.0, fs_o/2.0, fs_o/float(X_o.size))</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;            p2_f = sp1_f.plot(f_o, X_o, <span class="stringliteral">&quot;b&quot;</span>)</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;            sp1_f.set_xlim([<a class="code" href="namespacegr_1_1trellis.html#aa1d6afaca822df7b2a521046596d3230">min</a>(f_o), max(f_o)+1])</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;            sp1_f.set_ylim([-200.0, 50.0])</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;            sp1_f.set_title((<span class="stringliteral">&quot;Channel %d&quot;</span> % i), weight=<span class="stringliteral">&quot;bold&quot;</span>)</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;            sp1_f.set_xlabel(<span class="stringliteral">&quot;Frequency (Hz)&quot;</span>)</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;            sp1_f.set_ylabel(<span class="stringliteral">&quot;Power (dBW)&quot;</span>)</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;            x_o = scipy.array(d)</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;            t_o = scipy.arange(0, Tmax_o, Ts_o)</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;            sp2_o = fig2.add_subplot(Nrows, Ncols, 1+i)</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;            p2_o = sp2_o.plot(t_o, x_o.real, <span class="stringliteral">&quot;b&quot;</span>)</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;            p2_o = sp2_o.plot(t_o, x_o.imag, <span class="stringliteral">&quot;r&quot;)</span></div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;<span class="stringliteral">            sp2_o.set_xlim([<a class="code" href="namespacegr_1_1trellis.html#aa1d6afaca822df7b2a521046596d3230">min</a>(t_o), max(t_o)+1])</span></div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="stringliteral">            sp2_o.set_ylim([-2, 2])</span></div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;<span class="stringliteral">            sp2_o.set_title((&quot;Channel %d&quot;</span> % i), weight=<span class="stringliteral">&quot;bold&quot;</span>)</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;            sp2_o.set_xlabel(<span class="stringliteral">&quot;Time (s)&quot;</span>)</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;            sp2_o.set_ylabel(<span class="stringliteral">&quot;Amplitude&quot;</span>)</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;        pylab.show()</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;<span class="keywordflow">if</span> __name__ == <span class="stringliteral">&quot;__main__&quot;</span>:</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    <span class="keywordflow">try</span>:</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;        main()</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    <span class="keywordflow">except</span> KeyboardInterrupt:</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;        <span class="keywordflow">pass</span></div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div></div><!-- fragment --><h1><a class="anchor" id="pfb_arb_resampler"></a>
The PFB Arbitrary Resampler Kernel</h1>
<p>GNU Radio has a PFB arbitrary resampler block that can be used to resample a signal to any arbitrary and real resampling rate. The resampling feature is one that could easily be useful to other blocks, and so we have extracted the kernel of the resampler into its own class that can be used as such.</p>
<p>The PFB arbitrary resampler is defined in <a class="el" href="pfb__arb__resampler_8h.html">pfb_arb_resampler.h</a> and has the following constructor:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>gr {</div><div class="line">  <span class="keyword">namespace </span>filter {</div><div class="line">    <span class="keyword">namespace </span>kernel {</div><div class="line"></div><div class="line">        pfb_arb_resampler_XXX(<span class="keywordtype">float</span> rate,</div><div class="line">                              <span class="keyword">const</span> std::vector&lt;float&gt; &amp;<a class="code" href="interpolator__taps_8h.html#a30bf032e13c2a9fc4a98e14e390cd65a">taps</a>,</div><div class="line">                              <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> filter_size);</div><div class="line"></div><div class="line">    } <span class="comment">/* namespace kernel */</span></div><div class="line">  } <span class="comment">/* namespace filter */</span></div><div class="line">} <span class="comment">/* namespace gr */</span></div></div><!-- fragment --><p>Currently, only a 'ccf' and 'fff' version are defined. This kernel, like the block itself, takes in the resampling <code>rate</code> as a floating point number. The <code>taps</code> are passed as the baseband prototype filter, and the quantization error of the filter is determined by the <code>filter_size</code> parameter.</p>
<p>The prototype taps are generated like all other PFB filter taps. Specifically, we construct them generally as a lowpass filter at the maximum rate of the filter. In the case of these resamplers, the maximum rate is actually the number of filters.</p>
<p>A simple example follows. We construct a filter that will pass the entire passband of the original signal to be resampled. To make it easy, we work in normalized sample rates for this. The gain of the filter is set to filter_size to compensate for the upsampling, the sampling rate itself is also set to filter_size, which is assuming that the incoming signal is at a sampling rate of 1.0. We defined the passband to be 0.5 to pass the entire width of the original signal and set a transition band to 0.1. Note that this causes a bit of roll-off outside of the original passband and could lead to introducing some aliasing. More care should be taken to construct the passband and transition width of the filter for the given signal while keeping the total number of taps small. A stopband attenuation of 60 dB was used here, and again, this is a parameter we can adjust to alter the performance and size of the filter.</p>
<div class="fragment"><div class="line">firdes.low_pass_2(filter_size, filter_size, 0.5, 0.1, 60)</div></div><!-- fragment --><p>As is typical with the PFB filters, a filter size of 32 is generally an appropriate trade-off of accuracy, performance, and memory. This should provide an error roughly equivalent to the quanization error of using 16-bit fixed point representation. Generally, increasing over 32 provides some accuracy benefits without a huge increase in computational demands. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
