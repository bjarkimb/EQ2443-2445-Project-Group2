<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>GNU Radio Manual and C++ API Reference: UHD Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gnuradio_logo_icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GNU Radio Manual and C++ API Reference
   &#160;<span id="projectnumber">3.7.13.4</span>
   </div>
   <div id="projectbrief">The Free &amp; Open Software Radio Ecosystem</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_uhd.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">UHD Interface </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="uhd_introduction"></a>
Introduction</h1>
<p>This is the GNU Radio UHD package. It is the interface to the UHD library to connect to and send and receive data between the Ettus Research, LLC product line. To use the UHD blocks, the Python namespaces is in gnuradio.uhd, which would be normally imported as:</p>
<div class="fragment"><div class="line">from <a class="code" href="namespacegnuradio.html">gnuradio</a> <span class="keyword">import</span> <a class="code" href="namespaceuhd.html">uhd</a></div></div><!-- fragment --><p>The relevant blocks are listed in the <a class="el" href="group__uhd__blk.html">UHD Interface</a> group. The most important components are the <a class="el" href="classgr_1_1uhd_1_1usrp__source.html">gr::uhd::usrp_source</a> and <a class="el" href="classgr_1_1uhd_1_1usrp__sink.html">gr::uhd::usrp_sink</a> blocks, which act as receivers/transmitters. Both are derived from <a class="el" href="classgr_1_1uhd_1_1usrp__block.html">gr::uhd::usrp_block</a>, which defines many of the shared functions between those blocks.</p>
<h1><a class="anchor" id="uhd_external_docs"></a>
External Documentation</h1>
<p>Ettus Research maintains the comprehensive documentation to the underlying UHD driver, which can be found at:</p>
<p><a href="http://files.ettus.com/manual/">http://files.ettus.com/manual/</a></p>
<p>The list of classes in the UHD Doxygen is located at:</p>
<p><a href="http://files.ettus.com/manual/annotated.html">http://files.ettus.com/manual/annotated.html</a></p>
<h1><a class="anchor" id="uhd_command_syntax"></a>
Command Syntax</h1>
<p>The UHD sink and source can be controlled by a message port. These message ports take commands, which are PMTs formatted as described in <a class="el" href="page_msg_passing.html#msg_passing_commands">Using messages as commands</a>.</p>
<p>There is a legacy format, which will be deprecated in the future, where commands may be tuples, formatted as: </p><pre class="fragment">(command, value, [channel])
</pre><p>See older versions of this manual for documentation on this deprecated command format.</p>
<p>In general, every command consists of one or more key/value pairs (either stored as a PMT pair, or a dictionary). A full list of keys is listed below.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> command = <a class="code" href="namespacepmt.html#a7ab95721db5cbda1852f13a92eee5362">pmt::cons</a>( <span class="comment">// Make a pair</span></div><div class="line">    <a class="code" href="namespacepmt.html#a90faad6086ac00280e0cfd8bb541bd64">pmt::mp</a>(<span class="stringliteral">&quot;freq&quot;</span>), <span class="comment">// Key is &#39;freq&#39; =&gt; sets the frequency</span></div><div class="line">    <a class="code" href="namespacepmt.html#a90faad6086ac00280e0cfd8bb541bd64">pmt::mp</a>(1.1e9) <span class="comment">// Set the frequency to 1.1 GHz</span></div><div class="line">);</div><div class="line"><span class="comment">// Now pass &#39;command&#39; into the USRP block&#39;s command port</span></div></div><!-- fragment --><p>This PMT would set the frequency to 1.1 GHz on all channels. We make use of the <a class="el" href="namespacepmt.html#a90faad6086ac00280e0cfd8bb541bd64" title="Make pmt symbol. ">pmt::mp()</a> function which automatically sets the PMT types. Assume we only want to set the frequency on channel 1 (i.e. the second channel). In this case, we must construct a dictionary: </p><div class="fragment"><div class="line"><a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> command = <a class="code" href="namespacepmt.html#aba10563e3ab43b8d52f9cb13132047cf">pmt::make_dict</a>();</div><div class="line">command = <a class="code" href="namespacepmt.html#a15e351077c14dcba7cb982951bbbd05b">pmt::dict_add</a>(command, <a class="code" href="namespacepmt.html#a90faad6086ac00280e0cfd8bb541bd64">pmt::mp</a>(<span class="stringliteral">&quot;freq&quot;</span>), <a class="code" href="namespacepmt.html#a90faad6086ac00280e0cfd8bb541bd64">pmt::mp</a>(1.1e9)); <span class="comment">// Specify frequency</span></div><div class="line">command = <a class="code" href="namespacepmt.html#a15e351077c14dcba7cb982951bbbd05b">pmt::dict_add</a>(command, <a class="code" href="namespacepmt.html#a90faad6086ac00280e0cfd8bb541bd64">pmt::mp</a>(<span class="stringliteral">&quot;chan&quot;</span>), <a class="code" href="namespacepmt.html#a90faad6086ac00280e0cfd8bb541bd64">pmt::mp</a>(1)); <span class="comment">// Specify channel</span></div><div class="line"><span class="comment">// Now pass &#39;command&#39; into the USRP block&#39;s command port</span></div></div><!-- fragment --><p>This command structure becomes more intuitive when thinking of sending the command PMT as a function call, where the key/value pairs are argument names and values, respectively. In the above example, the behaviour is the same as if calling </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;usrp_source.set_center_freq(freq=1.1e9, chan=1)</div></div><!-- fragment --><p> The main difference is that we can add more properties to the same command PMT, e.g. as such: </p><div class="fragment"><div class="line"><span class="comment">// &#39;command&#39; is the same PMT as in the previous example</span></div><div class="line">command = <a class="code" href="namespacepmt.html#a15e351077c14dcba7cb982951bbbd05b">pmt::dict_add</a>(command, <a class="code" href="namespacepmt.html#a90faad6086ac00280e0cfd8bb541bd64">pmt::mp</a>(<span class="stringliteral">&quot;gain&quot;</span>), <a class="code" href="namespacepmt.html#a90faad6086ac00280e0cfd8bb541bd64">pmt::mp</a>(23.0)); <span class="comment">// Specify gain</span></div><div class="line">command = <a class="code" href="namespacepmt.html#a15e351077c14dcba7cb982951bbbd05b">pmt::dict_add</a>(command, <a class="code" href="namespacepmt.html#a90faad6086ac00280e0cfd8bb541bd64">pmt::mp</a>(<span class="stringliteral">&quot;antenna&quot;</span>), <a class="code" href="namespacepmt.html#a90faad6086ac00280e0cfd8bb541bd64">pmt::mp</a>(<span class="stringliteral">&quot;TX/RX&quot;</span>)); <span class="comment">// Switch antenna</span></div><div class="line"><span class="comment">// Now pass &#39;command&#39; into the USRP block&#39;s command port</span></div></div><!-- fragment --><p> When the USRP block interprets this command PMT, all properties will be set.</p>
<h2><a class="anchor" id="uhd_command_syntax_cmds"></a>
Common command keys</h2>
<p>The following command keys are understood by both UHD Source and Sink:</p>
<table class="doxtable">
<tr>
<th>Command name </th><th>Value Type </th><th>Description  </th></tr>
<tr>
<td><code>chan</code> </td><td>int </td><td>Specifies a channel. If this is not given, either all channels are chosen, or channel 0, depending on the action. A value of -1 forces 'all channels', where possible. </td></tr>
<tr>
<td><code>gain</code> </td><td>double </td><td>Sets the Tx or Rx gain (in dB). Defaults to all channels. </td></tr>
<tr>
<td><code>freq</code> </td><td>double </td><td>Sets the Tx or Rx frequency. Defaults to all channels. If specified without <code>lo_offset</code>, it will set the LO offset to zero. </td></tr>
<tr>
<td><code>lo_offset</code> </td><td>double </td><td>Sets an LO offset. Defaults to all channels. Note this does not affect the effective center frequency. </td></tr>
<tr>
<td><code>tune</code> </td><td>tune_request </td><td>Like freq, but sets a full tune request (i.e. center frequency and DSP offset). Defaults to all channels. </td></tr>
<tr>
<td><code>lo_freq</code> </td><td>double </td><td>For fully manual tuning: Set the LO frequency (RF frequency). Conflicts with <code>freq</code>, <code>lo_offset</code>, and <code>tune</code>. </td></tr>
<tr>
<td><code>dsp_freq</code> </td><td>double </td><td>For fully manual tuning: Set the DSP frequency (CORDIC frequency). Conflicts with <code>freq</code>, <code>lo_offset</code>, and <code>tune</code>. </td></tr>
<tr>
<td><code>direction</code> </td><td>string </td><td>Used for timed transceiver tuning to ensure tuning order is maintained. Values other than 'TX' or 'RX' will be ignored. </td></tr>
<tr>
<td><code>rate</code> </td><td>double </td><td>See usrp_block::set_samp_rate(). <em>Always</em> affects all channels. </td></tr>
<tr>
<td><code>bandwidth</code> </td><td>double </td><td>See usrp_block::set_bandwidth(). Defaults to all channels. </td></tr>
<tr>
<td><code>time</code> </td><td>timestamp </td><td>Sets a command time. See usrp_block::set_command_time(). A value of PMT_NIL will clear the command time. </td></tr>
<tr>
<td><code>mboard</code> </td><td>int </td><td>Specify mboard index, where applicable. </td></tr>
<tr>
<td><code>antenna</code> </td><td>string </td><td>See usrp_block::set_antenna(). Defaults to all channels. </td></tr>
</table>
<p>Special types:</p>
<ul>
<li>tune_request: Like a uhd::tune_request_t, but always uses POLICY_AUTO. This is a pair, composed of (target_frequency, lo_offset)</li>
<li>timestamp: A pair composed of (long full_secs, double frac_secs). Similar to uhd::time_spec_t</li>
</ul>
<p><b>Note:</b> Not all commands are affected by <code>time</code>. See the UHD manual for details on timed commands.</p>
<h2><a class="anchor" id="uhd_command_syntax_multi_vs_single"></a>
Dictionaries vs pairs</h2>
<p>Given the choices, it may be unclear if it's preferable to send multiple commands to the USRP block with a single key/value pair each, or send a single dict with all the values.</p>
<p>In general, the dictionary should be preferred. It has some distinct advantages:</p><ul>
<li>If it carries a timestamp, this timestamp is valid for all key/value pairs it may be applied to.</li>
<li>All settings will be applied at once. With multiple messages, other blocks might be sending interfering messages while the messages are being processed.</li>
</ul>
<h1><a class="anchor" id="uhd_configuring"></a>
Configuring a UHD object</h1>
<p>A typical option parser setup for a UHD device looks like</p>
<div class="fragment"><div class="line">parser = OptionParser(option_class=eng_option)</div><div class="line">parser.add_option(&quot;-a&quot;, &quot;--args&quot;, type=&quot;<span class="keywordtype">string</span>&quot;, default=&quot;&quot;,</div><div class="line">                  help=&quot;UHD device address args , [default=%default]&quot;)</div><div class="line">parser.add_option(&quot;&quot;, &quot;--spec&quot;, type=&quot;<span class="keywordtype">string</span>&quot;, default=None,</div><div class="line">                  help=&quot;Subdevice of UHD device where appropriate&quot;)</div><div class="line">parser.add_option(&quot;-A&quot;, &quot;--antenna&quot;, type=&quot;<span class="keywordtype">string</span>&quot;, default=None,</div><div class="line">                  help=&quot;select Rx Antenna where appropriate&quot;)</div><div class="line">parser.add_option(&quot;-s&quot;, &quot;--samp-rate&quot;, type=&quot;eng_float&quot;, default=1e6,</div><div class="line">                  help=&quot;set sample rate (bandwidth) [default=%default]&quot;)</div><div class="line">parser.add_option(&quot;-f&quot;, &quot;--freq&quot;, type=&quot;eng_float&quot;, default=None,</div><div class="line">                  help=&quot;set frequency to FREQ&quot;, metavar=&quot;FREQ&quot;)</div><div class="line">parser.add_option(&quot;-g&quot;, &quot;--gain&quot;, type=&quot;eng_float&quot;, default=None,</div><div class="line">                  help=&quot;set gain in dB (default is midpoint)&quot;)</div></div><!-- fragment --><p>To use these options to create a UHD source object:</p>
<div class="fragment"><div class="line"><span class="keyword">self</span>.u = <a class="code" href="namespaceuhd.html">uhd</a>.usrp_source(device_addr=options.args,</div><div class="line">                         io_type=<a class="code" href="namespaceuhd.html">uhd</a>.io_type.COMPLEX_FLOAT32,</div><div class="line">                         num_channels=1)</div><div class="line"></div><div class="line"><span class="keyword">self</span>.u.set_samp_rate(options.samp_rate)</div><div class="line"></div><div class="line"><span class="preprocessor"># if no gain was specified, use the mid-point in dB</span></div><div class="line"><span class="keywordflow">if</span> options.gain is None:</div><div class="line">    g = <span class="keyword">self</span>.u.get_gain_range()</div><div class="line">    options.gain = float(g.start()+g.stop())/2</div><div class="line"><span class="keyword">self</span>.u.set_gain(options.gain, 0)</div><div class="line"></div><div class="line"><span class="preprocessor"># Set the center frequency</span></div><div class="line"><span class="keyword">self</span>.u.set_center_freq(options.freq, 0)</div><div class="line"></div><div class="line"><span class="preprocessor"># Set the subdevice spec</span></div><div class="line"><span class="keywordflow">if</span>(options.spec):</div><div class="line">    <span class="keyword">self</span>.u.set_subdev_spec(options.spec, 0)</div><div class="line"></div><div class="line"><span class="preprocessor"> # Set the antenna</span></div><div class="line"> <span class="keywordflow">if</span>(options.antenna):</div><div class="line">    <span class="keyword">self</span>.u.set_antenna(options.antenna, 0)</div></div><!-- fragment --><p>Frequently, your application may need a sample rate that is not supported by the UHD device. If you have extra CPU power to spare, you can easily set the sample rate you want, then ask the device what the actual sample rate set was. Then, you can easily create an arbitrary resampler to take care of the difference.</p>
<div class="fragment"><div class="line"><span class="keyword">self</span>.u.set_samp_rate(options.samp_rate)</div><div class="line"></div><div class="line">desired_rate = options.samp_rate</div><div class="line">actual_rate = <span class="keyword">self</span>.u.get_samp_rate()</div><div class="line">resample = desired_rate / actual_rate</div><div class="line"></div><div class="line"><span class="preprocessor"># Use the filter.pfb version and pass only the resample factor.</span></div><div class="line"><span class="preprocessor"># This block builds a half-band filter for you</span></div><div class="line"></div><div class="line"><span class="keyword">self</span>.resampler = filter.pfb.arb_resampler_ccf(resample)</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
