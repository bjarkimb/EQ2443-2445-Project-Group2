<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>GNU Radio Manual and C++ API Reference: Digital Modulation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gnuradio_logo_icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GNU Radio Manual and C++ API Reference
   &#160;<span id="projectnumber">3.7.13.4</span>
   </div>
   <div id="projectbrief">The Free &amp; Open Software Radio Ecosystem</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_digital.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Digital Modulation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="digtial_introduction"></a>
Introduction</h1>
<p>This is the gr-digital package. It contains all of the digital modulation blocks, utilities, and examples. To use the digital blocks, the Python namespaces is in gnuradio.digital, which would be normally imported as:</p>
<div class="fragment"><div class="line">from <a class="code" href="namespacegnuradio.html">gnuradio</a> <span class="keyword">import</span> digital</div></div><!-- fragment --><p>See the Doxygen documentation for details about the blocks available in this package.</p>
<p>A quick listing of the details can be found in Python after importing by using:</p>
<div class="fragment"><div class="line">help(digital)</div></div><!-- fragment --><h1><a class="anchor" id="digital_constellations"></a>
Constellation Objects</h1>
<p>GNU Radio supports the creation and use of Constellation objects for many of its digital communications needs. We define these constellations with a set of constellation points in complex space and the symbol mappings to those points. For a constellation that has 4 symbols, it then has log2(4) = 2 bits/symbol. We define this constellation with:</p>
<pre>
    constel_points = [c0, c1, c2, c3]
    symbols = [s0, s1, s2, s3]
</pre><p>In this case: <img class="formulaInl" alt="$c_i \in C$" src="form_28.png"/> and <img class="formulaInl" alt="$s_i \in [00, 01, 10, 11]$" src="form_29.png"/>. Also, the mapping is a 1-to-1 for the items in both lists, so the symbol <img class="formulaInl" alt="$s_0$" src="form_30.png"/> is positioned in complex space at the point <img class="formulaInl" alt="$c_0$" src="form_31.png"/>.</p>
<p>In the code itself, the symbols are referred to as the 'pre_diff_code' since this is the mapping before the application of differential modulation, if used.</p>
<p>The constellation object classes are defined in <a class="el" href="constellation_8h.html">constellation.h</a>. There is a hierarchy of classes for different purposes and which represent special classes of constellations. The all derive from the virtual class <a class="el" href="classgr_1_1digital_1_1constellation.html" title="An abstracted constellation object. ">gr::digital::constellation</a>. All constellations we will make are based on classes derived from this base:</p>
<pre>
<a class="el" href="classgr_1_1digital_1_1constellation.html" title="An abstracted constellation object. ">gr::digital::constellation</a>
    --&gt; <a class="el" href="classgr_1_1digital_1_1constellation__calcdist.html" title="Calculate Euclidian distance for any constellation. ">gr::digital::constellation_calcdist</a>
    --&gt; <a class="el" href="classgr_1_1digital_1_1constellation__sector.html" title="Sectorized digital constellation. ">gr::digital::constellation_sector</a>
        --&gt; <a class="el" href="classgr_1_1digital_1_1constellation__rect.html" title="Rectangular digital constellationOnly implemented for 1-(complex)dimensional constellation. ">gr::digital::constellation_rect</a>
            --&gt; <a class="el" href="classgr_1_1digital_1_1constellation__expl__rect.html" title="Rectangular digital constellation. ">gr::digital::constellation_expl_rect</a>
        --&gt; <a class="el" href="classgr_1_1digital_1_1constellation__psk.html" title="constellation_pskConstellation space is divided into pie slices sectors. ">gr::digital::constellation_psk</a>
    --&gt; <a class="el" href="classgr_1_1digital_1_1constellation__bpsk.html" title="Digital constellation for BPSK . ">gr::digital::constellation_bpsk</a>
    --&gt; <a class="el" href="classgr_1_1digital_1_1constellation__qpsk.html" title="Digital constellation for QPSK. ">gr::digital::constellation_qpsk</a>
    --&gt; <a class="el" href="classgr_1_1digital_1_1constellation__dqpsk.html" title="Digital constellation for DQPSK. ">gr::digital::constellation_dqpsk</a>
    --&gt; <a class="el" href="classgr_1_1digital_1_1constellation__8psk.html" title="Digital constellation for 8PSK. ">gr::digital::constellation_8psk</a>
</pre><p>Each constellation class has a set of attributes and functions useful for manipulating the constellations and for converting symbols to and from complex points. One of the more important functions is the <a class="el" href="classgr_1_1digital_1_1constellation.html#aecc0c3b7b1042efe9100937988f7902b" title="Returns the constellation point that matches best. ">gr::digital::constellation::decision_maker</a> function that takes in a sample in complex space and returns the symbol that it maps to. How this calculation is performed generally distinguishes the constellation classes from each other.</p>
<p>The <a class="el" href="classgr_1_1digital_1_1constellation__calcdist.html" title="Calculate Euclidian distance for any constellation. ">gr::digital::constellation_calcdist</a> is the most generic constellation class we can create. This takes in the constellation points, symbol mapping, a rotational symmetry, and the number of dimensions. The decision_maker function takes in a complex sample x and calculates the Euclidean distance between x and each point in the constellation map of the object. The constellation point that has the minimum Euclidean distance to x is selected as the best match. The decision_maker will then return the symbol value that matches to this selected constellation point.</p>
<p>We then have a concept of a constellation with a well-defined concept of sectors in the <a class="el" href="classgr_1_1digital_1_1constellation__sector.html" title="Sectorized digital constellation. ">gr::digital::constellation_sector</a>. This is farther refined if we know that the constellation is rectangular and can use the <a class="el" href="classgr_1_1digital_1_1constellation__rect.html" title="Rectangular digital constellationOnly implemented for 1-(complex)dimensional constellation. ">gr::digital::constellation_rect</a> class. These classes have an overloaded decision_maker function that is specific to how the sectors are defined in the constructor. Essentially, the decision making math for this class is less costly than calculating the Euclidean distance for each point in the space. So if we can sectorize our constellation, using this class will be computationally cheaper.</p>
<p>Finally, we have a set of pre-defined, hard-coded constellations for BPSK (<a class="el" href="classgr_1_1digital_1_1constellation__bpsk.html" title="Digital constellation for BPSK . ">gr::digital::constellation_bpsk</a>), QPSK (<a class="el" href="classgr_1_1digital_1_1constellation__qpsk.html" title="Digital constellation for QPSK. ">gr::digital::constellation_qpsk</a>), DQPSK (<a class="el" href="classgr_1_1digital_1_1constellation__dqpsk.html" title="Digital constellation for DQPSK. ">gr::digital::constellation_dqpsk</a>), and 8PSK (<a class="el" href="classgr_1_1digital_1_1constellation__8psk.html" title="Digital constellation for 8PSK. ">gr::digital::constellation_8psk</a>). These derive directly from <a class="el" href="classgr_1_1digital_1_1constellation.html" title="An abstracted constellation object. ">gr::digital::constellation</a> and specifically overload the decision_maker function. We have very simple metrics for calculating decisions for each of these constellations. For BPSK, we simply slice on the real axis. Samples are based solely on whether the real part of the complex symbol x is greater than or less than 0. Similar, simple, decision makers are defined for the others.</p>
<p>Note that these specific constellations for the PSK modulations are defined for only one mapping of the constellation points to the symbols. Each is Gray coded, but for a specific Gray coding that is hard-coded into the class.</p>
<h2><a class="anchor" id="digital_grc_constellations"></a>
Constellation Objects in GRC</h2>
<p>GRC provides two constellation representations that we can use to more easily define and interact with constellation objects. These are located in the 'Modulators' category as 'Constellation Object' and 'Constellation Rect. Object'. These allow us to easily specify the constellation points, symbol list, and other properties of the constellation objects. They return the base() of the object, so the variable's ID can be used directly with blocks that accept constellation objects.</p>
<p>These constellation blocks also allow us to specify the soft decision LUT if using the constellation object for soft decision outputs. The input can either be 'None' (default), a list of the soft bits that were generated externally or by another function, or 'auto' where the block will automatically calculate the soft decisions based on the constellation points and symbol map.</p>
<h1><a class="anchor" id="digital_python_helpers"></a>
Python Constellation Helper Functions</h1>
<p>A series of helper functions are defined in Python to create different, common constellations. There are various functions that have various levels of complexity in their definitions.</p>
<h2><a class="anchor" id="digital_python_helpers_psk"></a>
PSK Python Helpers</h2>
<p>There are two modules imported directly into gnuradio.digital. The first is gr-digital/python/digital/psk.py and the second is gr-digital/python/digital/psk_constellations.py. The gr-digital/python/digital/psk.py module defines the following constellations:</p>
<pre>
    psk_constellation(m, mod_code, differential)
</pre><p>This function defines a PSK modulation of order 'm' (that is, there are m number of constellation points / symbols). The 'mod_code' is either mod_codes.GRAY_CODE or mode_codes.NO_CODE to set the symbol mapping up as either Gray coded or not. The 'differential' argument is either True to use differential coding or False for non-differential coding.</p>
<p>This function creates and returns a constellation object that can then be used by any block that takes a constellation (<a class="el" href="classgr_1_1digital_1_1constellation__decoder__cb.html" title="Constellation Decoder. ">gr::digital::constellation_decoder_cb</a>, <a class="el" href="classgr_1_1digital_1_1constellation__receiver__cb.html" title="This block makes hard decisions about the received symbols (using a constellation object) and also fi...">gr::digital::constellation_receiver_cb</a>, <a class="el" href="classgr_1_1digital_1_1constellation__soft__decoder__cf.html" title="Constellation Decoder. ">gr::digital::constellation_soft_decoder_cf</a>, or <a class="el" href="classgr_1_1digital_1_1lms__dd__equalizer__cc.html" title="Least-Mean-Square Decision Directed Equalizer (complex in/out) ">gr::digital::lms_dd_equalizer_cc</a>).</p>
<p>The gr-digital/python/digital/psk.py module also holds functions similar to digital.psk_constellation but that create a full modulator and demodulator chain derived from digital.generic_mod_demod.</p>
<pre>
    psk_mod(constellation_points, mod_code, differential, *args, **kwargs)
    psk_demod(constellation_points, mod_code, differential, *args, **kwargs)
</pre><p>The args and kwargs are parameters of the generic_mod or generic_demod passed directly to them. See <a class="el" href="page_digital.html#digital_generic_mod_demod">The Generic Modulator/Demodulator</a> for details of this interface.</p>
<p>There is another Python file full of helper functions to create different constellations. This is found in the gr-digital/python/digital/psk_constellation.py file. This file provides functions that build the vectors of constellation points and symbol mappings that can be used to create a constellation object. These are particularly helpful when using the Constellation Obj. and Constellation Rect. GUI elements in GRC.</p>
<p>The gr-digital/python/digital/psk_constellation.py file has extensive documentation that describes the naming scheme used for the different constellations that will not be repeated here. The main thing to understand is that these functions define constellations of the same order with different Gray code mappings. The function names are:</p>
<pre>
    (const_points, symbol_map) = psk_M_0xk_&lt;permutation&gt;()
</pre><p>Where M is the order of the modulation (2 for BPSK, 4 for QPSK, etc.), and k and &lt;permutation&gt; define a particular encoding for the Gray code mapping used. The documentation in the file explains how these two concepts define the Gray code mapping.</p>
<p>These functions are also simply named "psk_M_n" when n is an integer from 0 to N-1 for however many mappings are defined for that modulation. Not all modulations are fully defined, and the value for n has no other meaning except as a counter.</p>
<p>The functions return a tuple of lists. The first list in the tuple is the list of complex constellation points and the second list contains the symbols mapped to those points. These lists can then be passed to a constellation class directly to create a constellation of any Gray code mapping needed.</p>
<p>While not all Gray code mappings of the modulations are defined, there is a generator function to automatically build any rotation of a basis constellation:</p>
<pre>
    (const_points, symbol_map) = \
        constellation_map_generator(basis_cpoints, basis_symbols, k, pi)
</pre><p>We provide a basis constellation map and symbol map as the fundamental rotation of the constellation points. This function uses the k and pi inputs (see the discussion in psk_constellation.py for what these mean) to return a new rotation of the constellation's symbols. If the basis symbols are Gray coded than the output symbols will also be Gray coded. Note that this algorithm specifically depends on the constellation in complex space to be square to preserve the Gray code property.</p>
<h2><a class="anchor" id="digital_python_helpers_qam"></a>
QAM Python Helpers</h2>
<p>Similar to defining PSK modulations, GNU Radio also has helpers for some QAM modulations, found in gr-digital/python/digital/qam.py and gr-digital/python/digital/qam_constellations.py. Similar functions to what has been described for PSK exist here:</p>
<pre>
    qam_constellation(constellation_points, differential, mod_code,
                      large_ampls_to_corners)
    qam_mod(constellation_points, differential, mod_code, *args, **kwargs)
    qam_demod(constellation_points, differential, mod_code,
              large_ampls_to_corner, *args, **kwargs)
</pre><p>The parameters to these functions is the same as for the PSK equivalents. The new argument 'large_ampls_to_corner' is defined in the documentation as:</p>
<pre>
    large_ampls_to_corners:  If this is set to True then when the
        constellation is making decisions, points that are far outside
        the constellation are mapped to the closest corner rather than
        the closet constellation point.  This can help with phase
        locking.
</pre><p>Similarly, gr-digital/python/digital/qam_constellations.py defines a of QAM constellation functions that return a tuple containing the constellation points and the symbol mappings. The naming scheme is defined in depth in the module itself and is similar to the equivalent set of PSK functions.</p>
<p>Currently, only a subset of 16QAM symbol mappings are defined, but we can use of the constellation_map_generator function described in the previous section to define more mapping rotations for and square QAM modulation.</p>
<h1><a class="anchor" id="digital_generic_mod_demod"></a>
The Generic Modulator/Demodulator</h1>
<p>Hierarchical Blocks</p>
<p>Since digital modulation and demodulation are complex functions, the different parts can be done by different existing GNU Radio blocks. We have combined these into a generic modulator and generic demodulator hierarchical blocks to make access and use much easier. This file can be found as gr-digital/python/digital/generic_mod_demod.py.</p>
<h2><a class="anchor" id="digital_generic_mod"></a>
Generic Modulator</h2>
<p>The modulator constructor looks like:</p>
<pre>
    digital.generic_mod(constellation, differential, samples_per_symbol,
                        pre_diff_code, excess_bw, verbose, log)
</pre><p>The 'constellation' arg is a constellation object as defined above in <a class="el" href="page_digital.html#digital_constellations">Constellation Objects</a> and can represent any constellation mapping. The 'differential' arg is a bool to turn differential coding on/off. The block also performs pulse shaping and interpolates the pulse-shaped filter to some number of 'samples_per_symbol'. The pulse shaping is a root raised cosine filter defined by the excess bandwidth (or alpha) parameter called 'excess_bw.'</p>
<p>We can also turn on a verbose mode to output information to the user. The 'log' parameter toggles logging data on/off. When logging is turned on, it stores every stage of the modulation to a different file so that each stage can be independently analyzed.</p>
<h2><a class="anchor" id="digital_generic_demod"></a>
Generic Demodulator</h2>
<p>The demodulator looks like:</p>
<pre>
    digital.generic_demod(constellation, differential, samples_per_symbol,
                          pre_diff_code, excess_bw, freq_bw, timing_bw,
                          phase_bw, verbose, log)
</pre><p>The additional parameters to the demodulator are the loop bandwidths for the different signal recovery loops used internally. There are separate loops for frequency acquisition, timing acquisition, and fine frequency / phase acquisition, controlled in tern by each of the three 'X_bw' arguments. Otherwise, the arguments are the same as the modulator.</p>
<h2><a class="anchor" id="digital_generic_guts"></a>
Guts of the Modulator and Demodulator</h2>
<p>The generic modulator looks like the following:</p>
<pre>
    blocks.packed_to_unpacked_bb: takes in packed bytes
    digital.map_bb: maps baseband symbols to the pre-differential encoding
    digital.diff_encoder_bb: differentially encode symbols
    digital.chunks_to_symbols_bc: convert symbols to complex samples
    filter.pfb_arb_resampler_ccf: perform upsampling to samps/symbol and pulse shape
</pre><p>The mapping and chunks-to-symbols stages are done using the information provided by the constellation object.</p>
<p>Note that the modulator takes in packed bytes, which means that all 8 bits per byte are used and unpacked into k bits per symbol.</p>
<p>The generic demodulator looks like the following:</p>
<pre>
    digital.fll_band_edge_cc: Performs coarse frequency correction
    digital.pfb_clock_sync_ccf: Matched filtering and timing recovery
    digital.constellation_receiver_cb: Phase tracking and decision making (hard bits)
    digital.diff_decoder_bb: Differential decoding
    digital.map_bb: Map to pre-differential symbols
    blocks.unpack_k_bits_bb: Unpack k bits/symbol to a stream of bits
</pre><p>This block outputs unpacked bits, so each output item represents a single bit of data. A block like 'pack_k_bits' can be used following this to convert the data back into bytes.</p>
<h1><a class="anchor" id="digital_constellation_modulator"></a>
Constellation Modulator</h1>
<p>The Constellation Modulator, Constellation Receiver, and Constellation Decoder can all take Constellation Objects to define what they are meant to transmit and receive.</p>
<p>The gr::digital::constellation_modulator block takes as a parameter the reference to the constellation object. The block is very generic in that the mapping from bits to symbols is done based on the constellation object passed to it. The modulator block requires packed bits as the input stream (that is, all 8 bits of the stream contain information).</p>
<p>The other parameters of this block include a setting as to whether or not to differentially encode the symbols, the number of samples per symbols, and the excess bandwidth of the transmitted pulse-shaped signal.</p>
<p>We can set up the transmitter using the constellation modulator block and use the same constellation object at the receiver so we know the same constellation settings are being used.</p>
<h1><a class="anchor" id="digital_softbits"></a>
Support for Soft Decisions</h1>
<p>To support soft decisions of the receivers instead of the current hard decisions, the constellation objects also accept a soft decision look-up table (LUT) or can be told to generate a LUT based on the constellation points and symbol map.</p>
<p>All constellation objects can accept a new LUT using the <a class="el" href="classgr_1_1digital_1_1constellation.html#a7b4f20eff157d285470bb11c2a1dccc3" title="Define a soft decision look-up table. ">gr::digital::constellation::set_soft_dec_lut</a> function. This function takes in a LUT, which is a vector of floating point tuples (in C++ it is just a vector&lt;vector&lt;float&gt;&gt;) and a precision value that specifies how accurate the LUT is to a given number of bits.</p>
<p>The constellation objects also have two functions to calculate the soft decisions from their constellation and symbol map. The <a class="el" href="classgr_1_1digital_1_1constellation.html#a2f210b179a72d6e60b8d59a0c66e80a1" title="Calculate soft decisions for the given sample. ">gr::digital::constellation::calc_soft_dec</a> takes a complex number (and optional noise power) and returns the soft decisions as a list of floats. This function is used internally in the <a class="el" href="classgr_1_1digital_1_1constellation.html#a44e01dd4eff8c625c586a2f236a505ec" title="Generates the soft decision LUT based on constellation and symbol map. ">gr::digital::constellation::gen_soft_dec_lut</a>, which takes in the LUT's precision (as a number of bits) and an optional noise power estimate, if known. This function calculates the soft decisions itself. These functions are very expensive because each constellation point is taken into account during the calculation. We provide the <a class="el" href="classgr_1_1digital_1_1constellation.html#a7b4f20eff157d285470bb11c2a1dccc3" title="Define a soft decision look-up table. ">gr::digital::constellation::set_soft_dec_lut</a> in order to allow users to use one of the many known approximations to more quickly generate the soft decision LUT.</p>
<p>The <a class="el" href="classgr_1_1digital_1_1constellation.html#a2f210b179a72d6e60b8d59a0c66e80a1" title="Calculate soft decisions for the given sample. ">gr::digital::constellation::calc_soft_dec</a> function could be used instead of drawing directly from a LUT, which is probably only important if the noise floor or channel estimates are likely to change and we want to account for this in the decisions. The basic implementation of the soft decision calculation is the full calculation based on the distance between the sample and all points in the constellation space. If using this function for real-time decisions, a new object should inherit from the <a class="el" href="classgr_1_1digital_1_1constellation.html" title="An abstracted constellation object. ">gr::digital::constellation</a> class (or whichever child class is being used) and redefine this function with a faster approximation calculation.</p>
<p>Note: If no soft decision LUT is defined but <a class="el" href="classgr_1_1digital_1_1constellation.html#af40f67a78465490b2766e38c1cc52c2c" title="Returns the soft decisions for the given sample. ">gr::digital::constellation::soft_decision_maker</a> is called then the full calculation from <a class="el" href="classgr_1_1digital_1_1constellation.html#a2f210b179a72d6e60b8d59a0c66e80a1" title="Calculate soft decisions for the given sample. ">gr::digital::constellation::calc_soft_dec</a> is used by default.</p>
<p>The LUT is a list of tuples, where each index of the list is some quantized (to some number of bits of precision) point in the constellation space. At each index, there is a tuple of <em>k</em> soft bit values for a constellation with <em>k</em> bits/symbol.</p>
<p>To help with this, the file gr-digital/python/digital/soft_dec_lut_gen.py can be used to create these tables. The function digital.soft_dec_table_generator(generator, precision) function generates a LUT based on some generator function and the number of bits of precision required. This file contains documentation explaining the system better. Or the digital.soft_dec_table(constel, symbols, prec, npwr=1) can be used which takes in the constellation map and symbols to do the full raw calculation of the softbits as opposed to a generator function.</p>
<p>To further aid the LUT creation, the digital module also defines a number of functions that can be used as soft decision generators for the soft_dec_table function. These functions are found in psk_constellations.py and qam_constellations.py. These files were already mentioned as they contain a set of functions that return tuples of constellation points and Gray-mapped symbols for different modulations. But these files contain a second set of functions prefixed by 'sd_' which are soft decision LUT generator functions Each LUT generator takes in a complex value and returns the tuple of soft decisions for that point in complex space. To aid with this, soft_dec_lut_gen.py defines a 'calc_from_table' function that takes in a complex sample, the precision of the table, and the LUT itself and returns the tuple of soft decisions in the LUT that is closest to the given symbol. Each of these functions can be found directly from the 'digital' Python module.</p>
<p>The LUTs are defined from min to max constellation points in both the real and imaginary axes. That means that signals coming in outside of these bounds are clipped to 1. So there is no added certainty for values beyond these bounds.</p>
<p>The <a class="el" href="classgr_1_1digital_1_1constellation__soft__decoder__cf.html" title="Constellation Decoder. ">gr::digital::constellation_soft_decoder_cf</a> block takes in a constellation object where a soft decision LUT is defined. It takes in complex samples and produces a stream of floats of soft decisions. The soft decision outputs are not grouped together, it is just a stream of floats. So this block acts as an interpolator that takes in 1 complex sample and return <em>k</em> float for <em>k</em> bits per symbol.</p>
<h2><a class="anchor" id="soft_dec_api"></a>
Review of the Soft Decision API/Functions</h2>
<p>Files of interest: </p><ul>
<li>psk_constellations.py: PSK constellations and soft decision generators </li>
<li>qam_constellations.py: QAM constellations and soft decision generators </li>
<li>soft_dec_lut_gen.py: Functions to build soft decision LUTs and test them </li>
<li>test_soft_decisions.py: A script that generates a random complex sample and calculates the soft decisions using various methods. Plots the sample against the full constellation. Requires matplotlib installed.</li>
</ul>
<p>Functions: </p><ul>
<li>digital.sd_psk_2_*: Returns (constellation, symbol_map) lists for different rotations for BPSK. </li>
<li>digital.sd_psk_4_*: Returns (constellation, symbol_map) lists for different rotations for QPSK. </li>
<li>digital.sd_qam_16_*: Returns (constellation, symbol_map) lists for different rotations for 16QAM. </li>
<li>digital.soft_dec_table_generator: Takes in a generator function (like the digital.sd_XXX above) and creates a LUT to a specific precision. </li>
<li>digital.soft_dec_table: Takes in a constellation/symbol map and uses digital.calc_soft_dec to generate a LUT to a specific precision. </li>
<li>digital.calc_soft_dec: Takes a complex sample and calculates the soft decisions for a given constellation/symbol mapping. </li>
<li>digital.calc_soft_dec_from_table: Given a sample and a LUT, returns the soft decisions of the LUT for the nearest point to the sample.</li>
</ul>
<p>C++ Interface: </p><ul>
<li><a class="el" href="classgr_1_1digital_1_1constellation.html#a44e01dd4eff8c625c586a2f236a505ec" title="Generates the soft decision LUT based on constellation and symbol map. ">gr::digital::constellation::gen_soft_dec_lut</a>: uses calc_soft_dec to internally generate a soft decision LUT. </li>
<li><a class="el" href="classgr_1_1digital_1_1constellation.html#a2f210b179a72d6e60b8d59a0c66e80a1" title="Calculate soft decisions for the given sample. ">gr::digital::constellation::calc_soft_dec</a>: calculates the soft decisions for a given sample from the full constellation/symbol map. </li>
<li><a class="el" href="classgr_1_1digital_1_1constellation.html#a7b4f20eff157d285470bb11c2a1dccc3" title="Define a soft decision look-up table. ">gr::digital::constellation::set_soft_dec_lut</a>: Set the soft decision LUT from an externally-calculated LUT. </li>
<li><a class="el" href="classgr_1_1digital_1_1constellation.html#a1bc7a672bd0e59f6fca46f93ae28c05c" title="Returns True if the soft decision LUT has been defined, False otherwise. ">gr::digital::constellation::has_soft_dec_lut</a>: has the LUT been set/generated or not. </li>
<li><a class="el" href="classgr_1_1digital_1_1constellation.html#af40f67a78465490b2766e38c1cc52c2c" title="Returns the soft decisions for the given sample. ">gr::digital::constellation::soft_decision_maker</a>: Used by gr::digital::constellation_soft_decoder to convert samples to soft decisions. If a LUT is defined, uses it; else, uses calc_soft_dec. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
