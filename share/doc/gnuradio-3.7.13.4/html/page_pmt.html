<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>GNU Radio Manual and C++ API Reference: Polymorphic Types</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gnuradio_logo_icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GNU Radio Manual and C++ API Reference
   &#160;<span id="projectnumber">3.7.13.4</span>
   </div>
   <div id="projectbrief">The Free &amp; Open Software Radio Ecosystem</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_pmt.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Polymorphic Types </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="pmt_introduction"></a>
Introduction</h1>
<p>Polymorphic Types are opaque data types that are designed as generic containers of data that can be safely passed around between blocks and threads in GNU Radio. They are heavily used in the stream tags and message passing interfaces. The most complete list of PMT function is, of course, the source code, specifically the header file <a class="el" href="pmt_8h.html">pmt.h</a>. This manual page summarizes the most important features and points of PMTs.</p>
<p>Let's dive straight into some Python code and see how we can use PMTs:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; <span class="keyword">import</span> <a class="code" href="namespacepmt.html">pmt</a></div><div class="line">&gt;&gt;&gt; P = <a class="code" href="namespacepmt.html">pmt</a>.from_long(23)</div><div class="line">&gt;&gt;&gt; type(P)</div><div class="line">&lt;<span class="keyword">class </span>&#39;<a class="code" href="namespacepmt.html">pmt</a>.pmt_swig.swig_int_ptr&#39;&gt;</div><div class="line">&gt;&gt;&gt; <a class="code" href="namespacepmt.html#acf4beefce8c6c5c70bdce4e246a54886">print</a> P</div><div class="line">23</div><div class="line">&gt;&gt;&gt; P2 = <a class="code" href="namespacepmt.html">pmt</a>.from_complex(1j)</div><div class="line">&gt;&gt;&gt; type(P2)</div><div class="line">&lt;<span class="keyword">class </span>&#39;<a class="code" href="namespacepmt.html">pmt</a>.pmt_swig.swig_int_ptr&#39;&gt;</div><div class="line">&gt;&gt;&gt; <a class="code" href="namespacepmt.html#acf4beefce8c6c5c70bdce4e246a54886">print</a> P2</div><div class="line">0+1i</div><div class="line">&gt;&gt;&gt; <a class="code" href="namespacepmt.html">pmt</a>.<a class="code" href="gr__complex_8h.html#a2ea72f70accbd7fefca28b2690eda735">is_complex</a>(P2)</div><div class="line">True</div></div><!-- fragment --><p>First, the pmt module is imported. We assign two values (P and P2) with PMTs using the <a class="el" href="namespacepmt.html#aa90bbe45bf1ff1dd9db3b684ef59a97c" title="Return the pmt value that represents the integer x. ">from_long()</a> and <a class="el" href="namespacepmt.html#a1441d157003d06deddecadfad54c04a7" title="Return a complex number constructed of the given real and imaginary parts. ">from_complex()</a> calls, respectively. As we can see, they are both of the same type! This means we can pass these variables to C++ through SWIG, and C++ can handle this type accordingly.</p>
<p>The same code as above in C++ would look like this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pmt_8h.html">pmt/pmt.h</a>&gt;</span></div><div class="line"><span class="comment">// [...]</span></div><div class="line"><a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> P = <a class="code" href="namespacepmt.html#aa90bbe45bf1ff1dd9db3b684ef59a97c">pmt::from_long</a>(23);</div><div class="line">std::cout &lt;&lt; P &lt;&lt; std::endl;</div><div class="line"><a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> P2 = <a class="code" href="namespacepmt.html#a1441d157003d06deddecadfad54c04a7">pmt::from_complex</a>(<a class="code" href="gr__complex_8h.html#aec4bfe41433369afae9327f1b0bc9109">gr_complex</a>(0, 1)); <span class="comment">// Alternatively: pmt::from_complex(0, 1)</span></div><div class="line">std::cout &lt;&lt; P2 &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <a class="code" href="namespacepmt.html#a66ff253ffc263b2f93e4cf909bab191e">pmt::is_complex</a>(P2) &lt;&lt; std::endl;</div></div><!-- fragment --><p>Two things stand out in both Python and C++. First, we can simply print the contents of a PMT. How is this possible? Well, the PMTs have in-built capability to cast their value to a string (this is not possible with all types, though). Second, PMTs must obviously know their type, so we can query that, e.g. by calling the <a class="el" href="gr__complex_8h.html#a2ea72f70accbd7fefca28b2690eda735">is_complex()</a> method.</p>
<p>When assigning a non-PMT value to a PMT, we can use the from_* methods, and use the to_* methods to convert back:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> P_int = <a class="code" href="namespacepmt.html#aa90bbe45bf1ff1dd9db3b684ef59a97c">pmt::from_long</a>(42);</div><div class="line"><span class="keywordtype">int</span> i = <a class="code" href="namespacepmt.html#a3d080ca306711e629ccdaa5de60f4ee4">pmt::to_long</a>(P_int);</div><div class="line"><a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> P_double = <a class="code" href="namespacepmt.html#ad20c287c509e8470d03d1c8e97fea12d">pmt::from_double</a>(0.2);</div><div class="line"><span class="keywordtype">double</span> d = <a class="code" href="namespacepmt.html#a0f58166fe9f449249f5de7dc7b3ab754">pmt::to_double</a>(P_double);</div></div><!-- fragment --><p>String types play a bit of a special role in PMTs, as we will see later, and have their own converter:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> P_str = <a class="code" href="namespacepmt.html#a011a23aa4f257dbd672d9d5220b1a5dd">pmt::string_to_symbol</a>(<span class="stringliteral">&quot;spam&quot;</span>);</div><div class="line"><a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> P_str2 = <a class="code" href="namespacepmt.html#a2a19d2e56f6fbb5645ad17a5937b5f2f">pmt::intern</a>(<span class="stringliteral">&quot;spam&quot;</span>);</div><div class="line">std::string str = <a class="code" href="namespacepmt.html#a7211cb3e5efc5fc508637360f1e428f5">pmt::symbol_to_string</a>(P_str);</div></div><!-- fragment --><p>The <a class="el" href="namespacepmt.html#a2a19d2e56f6fbb5645ad17a5937b5f2f" title="Alias for pmt_string_to_symbol. ">pmt::intern</a> is another way of saying <a class="el" href="namespacepmt.html#a011a23aa4f257dbd672d9d5220b1a5dd" title="Return the symbol whose name is s. ">pmt::string_to_symbol</a>.</p>
<p>In Python, we can make use of the dynamic typing, and there's actually a helper function to do these conversions (C++ also has a helper function for converting to PMTs called <a class="el" href="namespacepmt.html#a90faad6086ac00280e0cfd8bb541bd64" title="Make pmt symbol. ">pmt::mp()</a>, but it's less powerful, and not quite as useful, because types are always strictly known in C++):</p>
<div class="fragment"><div class="line">P_int = <a class="code" href="namespacepmt.html">pmt</a>.to_pmt(42)</div><div class="line">i = <a class="code" href="namespacepmt.html">pmt</a>.to_python(P_int)</div><div class="line">P_double = <a class="code" href="namespacepmt.html">pmt</a>.to_pmt(0.2)</div><div class="line">d = <a class="code" href="namespacepmt.html">pmt</a>.to_double(P_double)</div></div><!-- fragment --><p>On a side note, there are three useful PMT constants, which can be used in both Python and C++ domains. In C++, these can be used as such:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> P_true = <a class="code" href="pmt_8h.html#a616d87aad0cb3ecdc80b70ae42b79cdf">pmt::PMT_T</a>;</div><div class="line"><a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> P_false = <a class="code" href="pmt_8h.html#a14555f1d3794ee65b982b9fb74adca9e">pmt::PMT_F</a>;</div><div class="line"><a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> P_nil = <a class="code" href="pmt_8h.html#aa83efad7d7f377e5c9e06279a93221da">pmt::PMT_NIL</a>;</div></div><!-- fragment --><p>In Python:</p>
<div class="fragment"><div class="line">P_true = <a class="code" href="namespacepmt.html">pmt</a>.PMT_T</div><div class="line">P_false = <a class="code" href="namespacepmt.html">pmt</a>.PMT_F</div><div class="line">P_nil = <a class="code" href="namespacepmt.html">pmt</a>.PMT_NIL</div></div><!-- fragment --><p>pmt.PMT_T and pmt.PMT_F are boolean PMT types.</p>
<p>To be able to go back to C++ data types, we need to be able to find out the type from a PMT. The family of is_* methods helps us do that:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> d;</div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="namespacepmt.html#a17ea5dc8103b201b6362c84bd03354c6">pmt::is_integer</a>(P)) {</div><div class="line">    d = (double) <a class="code" href="namespacepmt.html#a3d080ca306711e629ccdaa5de60f4ee4">pmt::to_long</a>(P);</div><div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespacepmt.html#a9b00d7520d07e00bdad3f3c8f14724ce">pmt::is_real</a>(P)) {</div><div class="line">    d = <a class="code" href="namespacepmt.html#a0f58166fe9f449249f5de7dc7b3ab754">pmt::to_double</a>(P);</div><div class="line">} <span class="keywordflow">else</span> {</div><div class="line">    <span class="comment">// We really expected an integer or a double here, so we don&#39;t know what to do</span></div><div class="line">    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;expected an integer!&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p>It is important to do type checking since we cannot unpack a PMT of the wrong data type.</p>
<p>We can compare PMTs without knowing their type by using the <a class="el" href="namespacepmt.html#a674f9fbdd25aafd8ca4d43cb3ebf2d2b">pmt::equal()</a> function:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="namespacepmt.html#a5c28635e14287cc0e2f762841c11032f">pmt::eq</a>(P_int, P_double)) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Equal!&quot;</span> &lt;&lt; std::endl; <span class="comment">// This line will never be reached</span></div></div><!-- fragment --><p>The rest of this page provides more depth into how to handle different data types with the PMT library.</p>
<h1><a class="anchor" id="pmt_datatype"></a>
PMT Data Type</h1>
<p>All PMTs are of the type <a class="el" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa" title="typedef for shared pointer (transparent reference counting). See http://www.boost.org/libs/smart_ptr/smart_ptr.htm ">pmt::pmt_t</a>. This is an opaque container and PMT functions must be used to manipulate and even do things like compare PMTs. PMTs are also <em>immutable</em> (except PMT vectors). We never change the data in a PMT; instead, we create a new PMT with the new data. The main reason for this is thread safety. We can pass PMTs as tags and messages between blocks and each receives its own copy that we can read from. However, we can never write to this object, and so if multiple blocks have a reference to the same PMT, there is no possibility of thread-safety issues of one reading the PMT data while another is writing the data. If a block is trying to write new data to a PMT, it actually creates a new PMT to put the data into. Thus we allow easy access to data in the PMT format without worrying about mutex locking and unlocking while manipulating them.</p>
<p>PMTs can represent the following:</p>
<ul>
<li>Boolean values of true/false</li>
<li>Strings (as symbols)</li>
<li>Integers (long and uint64)</li>
<li>Floats (as doubles)</li>
<li>Complex (as two doubles)</li>
<li>Pairs</li>
<li>Tuples</li>
<li>Vectors (of PMTs)</li>
<li>Uniform vectors (of any standard data type)</li>
<li>Dictionaries (list of key:value pairs)</li>
<li>Any (contains a boost::any pointer to hold anything)</li>
</ul>
<p>The PMT library also defines a set of functions that operate directly on PMTs such as:</p>
<ul>
<li>Equal/equivalence between PMTs</li>
<li>Length (of a tuple or vector)</li>
<li>Map (apply a function to all elements in the PMT)</li>
<li>Reverse</li>
<li>Get a PMT at a position in a list</li>
<li>Serialize and deserialize</li>
<li>Printing</li>
</ul>
<p>The constants in the PMT library are:</p>
<ul>
<li>pmt::PMT_T - a PMT True</li>
<li>pmt::PMT_F - a PMT False</li>
<li>pmt::PMT_NIL - an empty PMT (think Python's 'None')</li>
</ul>
<h1><a class="anchor" id="pmt_insert"></a>
Inserting and Extracting Data</h1>
<p>Use <a class="el" href="pmt_8h.html">pmt.h</a> for a complete guide to the list of functions used to create PMTs and get the data from a PMT. When using these functions, remember that while PMTs are opaque and designed to hold any data, the data underneath is still a C++ typed object, and so the right type of set/get function must be used for the data type.</p>
<p>Typically, a PMT object can be made from a scalar item using a call like "pmt::from_&lt;type&gt;". Similarly, when getting data out of a PMT, we use a call like "pmt::to_&lt;type&gt;". For example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> a = 1.2345;</div><div class="line"><a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> pmt_a = <a class="code" href="namespacepmt.html#ad20c287c509e8470d03d1c8e97fea12d">pmt::from_double</a>(a);</div><div class="line"><span class="keywordtype">double</span> b = <a class="code" href="namespacepmt.html#a0f58166fe9f449249f5de7dc7b3ab754">pmt::to_double</a>(pmt_a);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> c = 12345;</div><div class="line"><a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> pmt_c = <a class="code" href="namespacepmt.html#aa90bbe45bf1ff1dd9db3b684ef59a97c">pmt::from_long</a>(c);</div><div class="line"><span class="keywordtype">int</span> d = <a class="code" href="namespacepmt.html#a3d080ca306711e629ccdaa5de60f4ee4">pmt::to_long</a>(pmt_c);</div></div><!-- fragment --><p>As a side-note, making a PMT from a complex number is not obvious:</p>
<div class="fragment"><div class="line">std::complex&lt;double&gt; a(1.2, 3.4);</div><div class="line"><a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> pmt_a = <a class="code" href="namespacepmt.html#a084e29bd83a38fb8e12ef995caf1128b">pmt::make_rectangular</a>(a.real(), b.imag());</div><div class="line">std::complex&lt;double&gt; b = <a class="code" href="namespacepmt.html#a7e5395b0328218bbba346e3a764aa5b2">pmt::to_complex</a>(pmt_a);</div></div><!-- fragment --><p>Pairs, dictionaries, and vectors have different constructors and ways to manipulate them, and these are explained in their own sections.</p>
<h1><a class="anchor" id="pmt_strings"></a>
Strings</h1>
<p>PMTs have a way of representing short strings. These strings are actually stored as interned symbols in a hash table, so in other words, only one PMT object for a given string exists. If creating a new symbol from a string, if that string already exists in the hash table, the constructor will return a reference to the existing PMT.</p>
<p>We create strings with the following functions, where the second function, <a class="el" href="namespacepmt.html#a2a19d2e56f6fbb5645ad17a5937b5f2f" title="Alias for pmt_string_to_symbol. ">pmt::intern</a>, is simply an alias of the first.</p>
<div class="fragment"><div class="line"><a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> str0 = <a class="code" href="namespacepmt.html#a011a23aa4f257dbd672d9d5220b1a5dd">pmt::string_to_symbol</a>(std::string(<span class="stringliteral">&quot;some string&quot;</span>));</div><div class="line"><a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> str1 = <a class="code" href="namespacepmt.html#a2a19d2e56f6fbb5645ad17a5937b5f2f">pmt::intern</a>(std::string(<span class="stringliteral">&quot;some string&quot;</span>));</div></div><!-- fragment --><p>The string can be retrieved using the inverse function:</p>
<div class="fragment"><div class="line">std::string s = <a class="code" href="namespacepmt.html#a7211cb3e5efc5fc508637360f1e428f5">pmt::symbol_to_string</a>(str0);</div></div><!-- fragment --><h1><a class="anchor" id="pmt_tests"></a>
Tests and Comparisons</h1>
<p>The PMT library comes with a number of functions to test and compare PMT objects. In general, for any PMT data type, there is an equivalent "pmt::is_&lt;type&gt;". We can use these to test the PMT before trying to access the data inside. Expanding our examples above, we have:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> str0 = <a class="code" href="namespacepmt.html#a011a23aa4f257dbd672d9d5220b1a5dd">pmt::string_to_symbol</a>(std::string(<span class="stringliteral">&quot;some string&quot;</span>));</div><div class="line"><span class="keywordflow">if</span>(<a class="code" href="namespacepmt.html#a5d1896e2f304fe7d9e821dae54598d23">pmt::is_symbol</a>(str0))</div><div class="line">    std::string s = <a class="code" href="namespacepmt.html#a7211cb3e5efc5fc508637360f1e428f5">pmt::symbol_to_string</a>(str0);</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> a = 1.2345;</div><div class="line"><a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> pmt_a = <a class="code" href="namespacepmt.html#ad20c287c509e8470d03d1c8e97fea12d">pmt::from_double</a>(a);</div><div class="line"><span class="keywordflow">if</span>(pmt::is_double(pmt_a))</div><div class="line">    <span class="keywordtype">double</span> b = <a class="code" href="namespacepmt.html#a0f58166fe9f449249f5de7dc7b3ab754">pmt::to_double</a>(pmt_a);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> c = 12345;</div><div class="line"><a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> pmt_c = <a class="code" href="namespacepmt.html#aa90bbe45bf1ff1dd9db3b684ef59a97c">pmt::from_long</a>(c);</div><div class="line"><span class="keywordflow">if</span>(pmt::is_long(pmt_a))</div><div class="line">    <span class="keywordtype">int</span> d = <a class="code" href="namespacepmt.html#a3d080ca306711e629ccdaa5de60f4ee4">pmt::to_long</a>(pmt_c);</div><div class="line"></div><div class="line">\\ This will fail the test. Otherwise, trying to coerce \b pmt_c as a</div><div class="line">\\ double when internally it is a <span class="keywordtype">long</span> will result in an exception.</div><div class="line">if(pmt::is_double(pmt_a))</div><div class="line">    <span class="keywordtype">double</span> d = <a class="code" href="namespacepmt.html#a0f58166fe9f449249f5de7dc7b3ab754">pmt::to_double</a>(pmt_c);</div></div><!-- fragment --><h1><a class="anchor" id="pmt_dict"></a>
Dictionaries</h1>
<p>PMT dictionaries are lists of key:value pairs. They have a well-defined interface for creating, adding, removing, and accessing items in the dictionary. Note that every operation that changes the dictionary both takes a PMT dictionary as an argument and returns a PMT dictionary. The dictionary used as an input is not changed and the returned dictionary is a new PMT with the changes made there.</p>
<p>The following is a list of PMT dictionary functions. Click through to get more information on what each does.</p>
<ul>
<li>bool <a class="el" href="namespacepmt.html#a2b5a9b0e21ac7a90078ce5033182104e" title="Return true if obj is a dictionary (warning: also returns true for a pair) ">pmt::is_dict(const pmt_t &amp;obj)</a></li>
<li>pmt_t <a class="el" href="namespacepmt.html#aba10563e3ab43b8d52f9cb13132047cf" title="Make an empty dictionary. ">pmt::make_dict()</a></li>
<li>pmt_t <a class="el" href="namespacepmt.html#a15e351077c14dcba7cb982951bbbd05b" title="Return a new dictionary with key associated with value. ">pmt::dict_add(const pmt_t &amp;dict, const pmt_t &amp;key, const pmt_t &amp;value)</a></li>
<li>pmt_t <a class="el" href="namespacepmt.html#aa06eff9f3a4e05a65072f1398bb4506f" title="Return a new dictionary with key removed. ">pmt::dict_delete(const pmt_t &amp;dict, const pmt_t &amp;key)</a></li>
<li>bool <a class="el" href="namespacepmt.html#a04b50148b5db6420f968694f093189a1" title="Return true if key exists in dict. ">pmt::dict_has_key(const pmt_t &amp;dict, const pmt_t &amp;key)</a></li>
<li>pmt_t <a class="el" href="namespacepmt.html#a01ed29a1a5fc85c8834d5c061e3bd506" title="If key exists in dict, return associated value; otherwise return not_found. ">pmt::dict_ref(const pmt_t &amp;dict, const pmt_t &amp;key, const pmt_t &amp;not_found)</a></li>
<li>pmt_t <a class="el" href="namespacepmt.html#a0f26f38e24c533a8476dfb993a2bc7a7" title="Return list of (key . value) pairs. ">pmt::dict_items(pmt_t dict)</a></li>
<li>pmt_t <a class="el" href="namespacepmt.html#a6454be0396459f54ea8ca2f7bd574ddc" title="Return list of keys. ">pmt::dict_keys(pmt_t dict)</a></li>
<li>pmt_t <a class="el" href="namespacepmt.html#a9e4f9bbf3db213c66c11314483942b4a" title="Return list of values. ">pmt::dict_values(pmt_t dict)</a></li>
</ul>
<p>This example does some basic manipulations of PMT dictionaries in Python. Notice that we pass the dictionary <em>a</em> and return the results to <em>a</em>. This still creates a new dictionary and removes the local reference to the old dictionary. This just keeps our number of variables small.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> <a class="code" href="namespacepmt.html">pmt</a></div><div class="line"></div><div class="line">key0 = <a class="code" href="namespacepmt.html">pmt</a>.intern(<span class="stringliteral">&quot;int&quot;</span>)</div><div class="line">val0 = <a class="code" href="namespacepmt.html">pmt</a>.from_long(123)</div><div class="line">val1 = <a class="code" href="namespacepmt.html">pmt</a>.from_long(234)</div><div class="line"></div><div class="line">key1 = <a class="code" href="namespacepmt.html">pmt</a>.intern(<span class="stringliteral">&quot;double&quot;</span>)</div><div class="line">val2 = <a class="code" href="namespacepmt.html">pmt</a>.from_double(5.4321)</div><div class="line"></div><div class="line"><span class="preprocessor"># Make an empty dictionary</span></div><div class="line">a = <a class="code" href="namespacepmt.html">pmt</a>.make_dict()</div><div class="line"></div><div class="line"><span class="preprocessor"># Add a key:value pair to the dictionary</span></div><div class="line">a = <a class="code" href="namespacepmt.html">pmt</a>.dict_add(a, key0, val0)</div><div class="line"><a class="code" href="namespacepmt.html#acf4beefce8c6c5c70bdce4e246a54886">print</a> a</div><div class="line"></div><div class="line"><span class="preprocessor"># Add a new value to the same key;</span></div><div class="line"><span class="preprocessor"># new dict will still have one item with new value</span></div><div class="line">a = <a class="code" href="namespacepmt.html">pmt</a>.dict_add(a, key0, val1)</div><div class="line"><a class="code" href="namespacepmt.html#acf4beefce8c6c5c70bdce4e246a54886">print</a> a</div><div class="line"></div><div class="line"><span class="preprocessor"># Add a new key:value pair</span></div><div class="line">a = <a class="code" href="namespacepmt.html">pmt</a>.dict_add(a, key1, val2)</div><div class="line"><a class="code" href="namespacepmt.html#acf4beefce8c6c5c70bdce4e246a54886">print</a> a</div><div class="line"></div><div class="line"><span class="preprocessor"># Test if we have a key, then delete it</span></div><div class="line"><a class="code" href="namespacepmt.html#acf4beefce8c6c5c70bdce4e246a54886">print</a> <a class="code" href="namespacepmt.html">pmt</a>.dict_has_key(a, key1)</div><div class="line">a = <a class="code" href="namespacepmt.html">pmt</a>.dict_delete(a, key1)</div><div class="line"><a class="code" href="namespacepmt.html#acf4beefce8c6c5c70bdce4e246a54886">print</a> <a class="code" href="namespacepmt.html">pmt</a>.dict_has_key(a, key1)</div><div class="line"></div><div class="line">ref = <a class="code" href="namespacepmt.html">pmt</a>.dict_ref(a, key0, <a class="code" href="namespacepmt.html">pmt</a>.PMT_NIL)</div><div class="line"><a class="code" href="namespacepmt.html#acf4beefce8c6c5c70bdce4e246a54886">print</a> ref</div><div class="line"></div><div class="line"><span class="preprocessor"># The following should never print</span></div><div class="line"><span class="keywordflow">if</span>(<a class="code" href="namespacepmt.html">pmt</a>.dict_has_key(a, key0) and <a class="code" href="namespacepmt.html">pmt</a>.eq(ref, <a class="code" href="namespacepmt.html">pmt</a>.PMT_NIL)):</div><div class="line">    <a class="code" href="namespacepmt.html#acf4beefce8c6c5c70bdce4e246a54886">print</a> <span class="stringliteral">&quot;Trouble! We have key0, but it returned PMT_NIL&quot;</span></div></div><!-- fragment --><h1><a class="anchor" id="pmt_vectors"></a>
Vectors</h1>
<p>PMT vectors come in two forms: vectors of PMTs and vectors of uniform data. The standard PMT vector is a vector of PMTs, and each PMT can be of any internal type. On the other hand, uniform PMTs are of a specific data type which come in the form:</p>
<ul>
<li>(u)int8</li>
<li>(u)int16</li>
<li>(u)int32</li>
<li>(u)int64</li>
<li>float32</li>
<li>float64</li>
<li>complex 32 (std::complex&lt;float&gt;)</li>
<li>complex 64 (std::complex&lt;double&gt;)</li>
</ul>
<p>That is, the standard sizes of integers, floats, and complex types of both signed and unsigned.</p>
<p>Vectors have a well-defined interface that allows us to make, set, get, and fill them. We can also get the length of a vector with <a class="el" href="namespacepmt.html#a8b181f253f877ade7bb7bf37d0b64627" title="Return the number of elements in v. ">pmt::length</a>.</p>
<p>For standard vectors, these functions look like:</p>
<ul>
<li>bool <a class="el" href="namespacepmt.html#a7778c57e723aa3f31d77642573636a7f" title="Return true if x is a vector, otherwise false. ">pmt::is_vector(pmt_t x)</a></li>
<li>pmt_t <a class="el" href="namespacepmt.html#a28cb6d7111a2ddd867169c25b82a0726" title="Make a vector of length k, with initial values set to fill. ">pmt::make_vector(size_t k, pmt_t fill)</a></li>
<li>pmt_t <a class="el" href="namespacepmt.html#af5a4b5f3ebafc22c8439c7fa025f20fb">pmt::vector_ref(pmt_t vector, size_t k)</a></li>
<li>void <a class="el" href="namespacepmt.html#a66cba432beae9911a31d841961621f90" title="Store obj in position k. ">pmt::vector_set(pmt_t vector, size_t k, pmt_t obj)</a></li>
<li>void <a class="el" href="namespacepmt.html#a3a1b1adcad8aaf47ff4459dd29253827" title="Store fill in every position of vector. ">pmt::vector_fill(pmt_t vector, pmt_t fill)</a></li>
</ul>
<p>Uniform vectors have the same types of functions, but they are data type-dependent. The following list tries to explain them where you substitute the specific data type prefix for <em>dtype</em> (prefixes being: u8, u16, u32, u64, s8, s16, s32, s64, f32, f64, c32, c64).</p>
<ul>
<li>bool pmt::is_(dtype)vector(pmt_t x)</li>
<li>pmt_t pmt::make_(dtype)vector(size_t k, (dtype) fill)</li>
<li>pmt_t pmt::init_(dtype)vector(size_t k, const (dtype*) data)</li>
<li>pmt_t pmt::init_(dtype)vector(size_t k, const std::vector&lt;dtype&gt; data)</li>
<li>pmt_t pmt::(dtype)vector_ref(pmt_t vector, size_t k)</li>
<li>void pmt::(dtype)vector_set(pmt_t vector, size_t k, (dtype) x)</li>
<li>const dtype* pmt::(dtype)vector_elements(pmt_t vector, size_t &amp;len)</li>
<li>dtype* pmt::(dtype)vector_writable_elements(pmt_t vector, size_t &amp;len)</li>
</ul>
<p><b>Note:</b> We break the contract with vectors. The 'set' functions actually change the data underneath. It is important to keep track of the implications of setting a new value as well as accessing the 'vector_writable_elements' data. Since these are mostly standard data types, sets and gets are atomic, so it is unlikely to cause a great deal of harm. But it's only unlikely, not impossible. Best to use mutexes whenever manipulating data in a vector.</p>
<h2><a class="anchor" id="pmt_blob"></a>
BLOB</h2>
<p>A BLOB is a 'binary large object' type. In PMT's, this is actually just a thin wrapper around a u8vector.</p>
<h1><a class="anchor" id="pmt_pairs"></a>
Pairs</h1>
<p>Pairs are inspired by LISP 'cons' data types, so you will find the language here comes from LISP. A pair is just a pair of PMT objects. They are manipulated using the following functions:</p>
<ul>
<li>bool <a class="el" href="namespacepmt.html#a936ecb38da9a2a1bb107c090e194700f" title="Return true if obj is a pair, else false (warning: also returns true for a dict) ">pmt::is_pair(const pmt_t &amp;obj)</a>: Return true if obj is a pair, else false</li>
<li>pmt_t <a class="el" href="namespacepmt.html#a7ab95721db5cbda1852f13a92eee5362" title="Return a newly allocated pair whose car is x and whose cdr is y. ">pmt::cons(const pmt_t &amp;x, const pmt_t &amp;y)</a>: construct new pair</li>
<li>pmt_t <a class="el" href="namespacepmt.html#a8bd91eddfdb4acc2931368f1bccddee7" title="If pair is a pair, return the car of the pair, otherwise raise wrong_type. ">pmt::car(const pmt_t &amp;pair)</a>: get the car of the pair (first object)</li>
<li>pmt_t <a class="el" href="namespacepmt.html#a0554cdcab4ea41692df1c7275787e2b8" title="If pair is a pair, return the cdr of the pair, otherwise raise wrong_type. ">pmt::cdr(const pmt_t &amp;pair)</a>: get the cdr of the pair (second object)</li>
<li>void <a class="el" href="namespacepmt.html#a4820a4d4a170ea6fd46d982f3034dee1" title="Stores value in the car field of pair. ">pmt::set_car(pmt_t pair, pmt_t value)</a>: Stores value in the car field</li>
<li>void <a class="el" href="namespacepmt.html#a27e2f629365e985c8ae26f87d58bf41c" title="Stores value in the cdr field of pair. ">pmt::set_cdr(pmt_t pair, pmt_t value)</a>: Stores value in the cdr field</li>
</ul>
<h1><a class="anchor" id="pmt_serdes"></a>
Serializing and Deserializing</h1>
<p>It is often important to hide the fact that we are working with PMTs to make them easier to transmit, store, write to file, etc. The PMT library has methods to serialize data into a string buffer or a string and then methods to deserialize the string buffer or string back into a PMT. We use this extensively in the metadata files (see <a class="el" href="page_metadata.html">Metadata Information</a>).</p>
<ul>
<li>bool <a class="el" href="namespacepmt.html#af83ab5e196d7e1d8ee5a5ad59005cabd" title="Write portable byte-serial representation of obj to sink. ">pmt::serialize(pmt_t obj, std::streambuf &amp;sink)</a></li>
<li>std::string <a class="el" href="namespacepmt.html#a1d54fe01f68a0452b722c8eac6b957b4" title="Provide a simple string generating interface to pmt&#39;s serialize function. ">pmt::serialize_str(pmt_t obj)</a></li>
<li>pmt_t <a class="el" href="namespacepmt.html#ad1e591fc168bae6870d05a412025b06b" title="Create obj from portable byte-serial representation. ">pmt::deserialize(std::streambuf &amp;source)</a></li>
<li>pmt_t <a class="el" href="namespacepmt.html#a4f3088f6a23609785ac58343bce49448" title="Provide a simple string generating interface to pmt&#39;s deserialize function. ">pmt::deserialize_str(std::string str)</a></li>
</ul>
<p>For example, we will serialize the data above to make it into a string ready to be written to a file and then deserialize it back to its original PMT.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> <a class="code" href="namespacepmt.html">pmt</a></div><div class="line"></div><div class="line">key0 = <a class="code" href="namespacepmt.html">pmt</a>.intern(<span class="stringliteral">&quot;int&quot;</span>)</div><div class="line">val0 = <a class="code" href="namespacepmt.html">pmt</a>.from_long(123)</div><div class="line"></div><div class="line">key1 = <a class="code" href="namespacepmt.html">pmt</a>.intern(<span class="stringliteral">&quot;double&quot;</span>)</div><div class="line">val1 = <a class="code" href="namespacepmt.html">pmt</a>.from_double(5.4321)</div><div class="line"></div><div class="line"><span class="preprocessor"># Make an empty dictionary</span></div><div class="line">a = <a class="code" href="namespacepmt.html">pmt</a>.make_dict()</div><div class="line"></div><div class="line"><span class="preprocessor"># Add a key:value pair to the dictionary</span></div><div class="line">a = <a class="code" href="namespacepmt.html">pmt</a>.dict_add(a, key0, val0)</div><div class="line">a = <a class="code" href="namespacepmt.html">pmt</a>.dict_add(a, key1, val1)</div><div class="line"></div><div class="line"><a class="code" href="namespacepmt.html#acf4beefce8c6c5c70bdce4e246a54886">print</a> a</div><div class="line"></div><div class="line">ser_str = <a class="code" href="namespacepmt.html">pmt</a>.serialize_str(a)</div><div class="line"><a class="code" href="namespacepmt.html#acf4beefce8c6c5c70bdce4e246a54886">print</a> ser_str</div><div class="line"></div><div class="line">b = <a class="code" href="namespacepmt.html">pmt</a>.deserialize_str(ser_str)</div><div class="line"><a class="code" href="namespacepmt.html#acf4beefce8c6c5c70bdce4e246a54886">print</a> b</div></div><!-- fragment --><p>The line where we 'print ser_str' will print and parts will be readable, but the point of serializing is not to make a human-readable string. This is only done here as a test.</p>
<h1><a class="anchor" id="pmt_printing"></a>
Printing</h1>
<p>In Python, the <b>repr</b> function of a PMT object is overloaded to call '<a class="el" href="namespacepmt.html#aa48a5afe66ea264a178dd1f553674982">pmt::write_string</a>'. This means that any time we call a formatted printing operation on a PMT object, the PMT library will properly format the object for display.</p>
<p>In C++, we can use the 'pmt::print(object)' function or print the contents is using the overloaded "&lt;&lt;" operator with a stream buffer object. In C++, we can inline print the contents of a PMT like:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa">pmt::pmt_t</a> a <a class="code" href="namespacepmt.html#ad20c287c509e8470d03d1c8e97fea12d">pmt::from_double</a>(1.0);</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The PMT a contains &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</div></div><!-- fragment --><h1><a class="anchor" id="pmt_python"></a>
Conversion between Python Objects and PMTs</h1>
<p>Although PMTs can be manipulated in Python using the Python versions of the C++ interfaces, there are some additional goodies that make it easier to work with PMTs in python. There are functions to automate the conversion between PMTs and Python types for booleans, strings, integers, longs, floats, complex numbers, dictionaries, lists, tuples and combinations thereof.</p>
<p>Two functions capture most of this functionality:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacepmt.html">pmt</a>.to_pmt    # Converts a python <span class="keywordtype">object</span> to a PMT.</div><div class="line">pmt.to_python # Converts a PMT into a python <span class="keywordtype">object</span>.</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
